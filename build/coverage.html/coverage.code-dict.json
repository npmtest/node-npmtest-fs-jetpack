{"/home/travis/build/npmtest/node-npmtest-fs-jetpack/test.js":"/* istanbul instrument in package npmtest_fs_jetpack */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/lib.npmtest_fs_jetpack.js":"/* istanbul instrument in package npmtest_fs_jetpack */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_fs_jetpack = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_fs_jetpack = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-fs-jetpack && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_fs_jetpack */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_fs_jetpack\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_fs_jetpack.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_fs_jetpack.rollup.js'] =\n            local.assetsDict['/assets.npmtest_fs_jetpack.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_fs_jetpack.__dirname + '/lib.npmtest_fs_jetpack.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/main.js":"'use strict';\n\nvar jetpack = require('./lib/jetpack');\n\nmodule.exports = jetpack();\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/jetpack.js":"/* eslint no-param-reassign:0 */\n\n'use strict';\n\nvar util = require('util');\nvar pathUtil = require('path');\nvar append = require('./append');\nvar dir = require('./dir');\nvar file = require('./file');\nvar find = require('./find');\nvar inspect = require('./inspect');\nvar inspectTree = require('./inspect_tree');\nvar copy = require('./copy');\nvar exists = require('./exists');\nvar list = require('./list');\nvar move = require('./move');\nvar read = require('./read');\nvar remove = require('./remove');\nvar rename = require('./rename');\nvar symlink = require('./symlink');\nvar streams = require('./streams');\nvar write = require('./write');\n\n// The Jetpack Context object.\n// It provides the public API, and resolves all paths regarding to\n// passed cwdPath, or default process.cwd() if cwdPath was not specified.\nvar jetpackContext = function (cwdPath) {\n  var getCwdPath = function () {\n    return cwdPath || process.cwd();\n  };\n\n  var cwd = function () {\n    var args;\n    var pathParts;\n\n    // return current CWD if no arguments specified...\n    if (arguments.length === 0) {\n      return getCwdPath();\n    }\n\n    // ...create new CWD context otherwise\n    args = Array.prototype.slice.call(arguments);\n    pathParts = [getCwdPath()].concat(args);\n    return jetpackContext(pathUtil.resolve.apply(null, pathParts));\n  };\n\n  // resolves path to inner CWD path of this jetpack instance\n  var resolvePath = function (path) {\n    return pathUtil.resolve(getCwdPath(), path);\n  };\n\n  var getPath = function () {\n    // add CWD base path as first element of arguments array\n    Array.prototype.unshift.call(arguments, getCwdPath());\n    return pathUtil.resolve.apply(null, arguments);\n  };\n\n  var normalizeOptions = function (options) {\n    var opts = options || {};\n    opts.cwd = getCwdPath();\n    return opts;\n  };\n\n  // API\n\n  var api = {\n    cwd: cwd,\n    path: getPath,\n\n    append: function (path, data, options) {\n      append.validateInput('append', path, data, options);\n      append.sync(resolvePath(path), data, options);\n    },\n    appendAsync: function (path, data, options) {\n      append.validateInput('appendAsync', path, data, options);\n      return append.async(resolvePath(path), data, options);\n    },\n\n    copy: function (from, to, options) {\n      copy.validateInput('copy', from, to, options);\n      copy.sync(resolvePath(from), resolvePath(to), options);\n    },\n    copyAsync: function (from, to, options) {\n      copy.validateInput('copyAsync', from, to, options);\n      return copy.async(resolvePath(from), resolvePath(to), options);\n    },\n\n    createWriteStream: function (path, options) {\n      return streams.createWriteStream(resolvePath(path), options);\n    },\n    createReadStream: function (path, options) {\n      return streams.createReadStream(resolvePath(path), options);\n    },\n\n    dir: function (path, criteria) {\n      var normalizedPath;\n      dir.validateInput('dir', path, criteria);\n      normalizedPath = resolvePath(path);\n      dir.sync(normalizedPath, criteria);\n      return cwd(normalizedPath);\n    },\n    dirAsync: function (path, criteria) {\n      dir.validateInput('dirAsync', path, criteria);\n      return new Promise(function (resolve, reject) {\n        var normalizedPath = resolvePath(path);\n        dir.async(normalizedPath, criteria)\n        .then(function () {\n          resolve(cwd(normalizedPath));\n        }, reject);\n      });\n    },\n\n    exists: function (path) {\n      exists.validateInput('exists', path);\n      return exists.sync(resolvePath(path));\n    },\n    existsAsync: function (path) {\n      exists.validateInput('existsAsync', path);\n      return exists.async(resolvePath(path));\n    },\n\n    file: function (path, criteria) {\n      file.validateInput('file', path, criteria);\n      file.sync(resolvePath(path), criteria);\n      return this;\n    },\n    fileAsync: function (path, criteria) {\n      var that = this;\n      file.validateInput('fileAsync', path, criteria);\n      return new Promise(function (resolve, reject) {\n        file.async(resolvePath(path), criteria)\n        .then(function () {\n          resolve(that);\n        }, reject);\n      });\n    },\n\n    find: function (startPath, options) {\n      // startPath is optional parameter, if not specified move rest of params\n      // to proper places and default startPath to CWD.\n      if (typeof options === 'undefined' && typeof startPath === 'object') {\n        options = startPath;\n        startPath = '.';\n      }\n      find.validateInput('find', startPath, options);\n      return find.sync(resolvePath(startPath), normalizeOptions(options));\n    },\n    findAsync: function (startPath, options) {\n      // startPath is optional parameter, if not specified move rest of params\n      // to proper places and default startPath to CWD.\n      if (typeof options === 'undefined' && typeof startPath === 'object') {\n        options = startPath;\n        startPath = '.';\n      }\n      find.validateInput('findAsync', startPath, options);\n      return find.async(resolvePath(startPath), normalizeOptions(options));\n    },\n\n    inspect: function (path, fieldsToInclude) {\n      inspect.validateInput('inspect', path, fieldsToInclude);\n      return inspect.sync(resolvePath(path), fieldsToInclude);\n    },\n    inspectAsync: function (path, fieldsToInclude) {\n      inspect.validateInput('inspectAsync', path, fieldsToInclude);\n      return inspect.async(resolvePath(path), fieldsToInclude);\n    },\n\n    inspectTree: function (path, options) {\n      inspectTree.validateInput('inspectTree', path, options);\n      return inspectTree.sync(resolvePath(path), options);\n    },\n    inspectTreeAsync: function (path, options) {\n      inspectTree.validateInput('inspectTreeAsync', path, options);\n      return inspectTree.async(resolvePath(path), options);\n    },\n\n    list: function (path) {\n      list.validateInput('list', path);\n      return list.sync(resolvePath(path || '.'));\n    },\n    listAsync: function (path) {\n      list.validateInput('listAsync', path);\n      return list.async(resolvePath(path || '.'));\n    },\n\n    move: function (from, to) {\n      move.validateInput('move', from, to);\n      move.sync(resolvePath(from), resolvePath(to));\n    },\n    moveAsync: function (from, to) {\n      move.validateInput('moveAsync', from, to);\n      return move.async(resolvePath(from), resolvePath(to));\n    },\n\n    read: function (path, returnAs) {\n      read.validateInput('read', path, returnAs);\n      return read.sync(resolvePath(path), returnAs);\n    },\n    readAsync: function (path, returnAs) {\n      read.validateInput('readAsync', path, returnAs);\n      return read.async(resolvePath(path), returnAs);\n    },\n\n    remove: function (path) {\n      remove.validateInput('remove', path);\n      // If path not specified defaults to CWD\n      remove.sync(resolvePath(path || '.'));\n    },\n    removeAsync: function (path) {\n      remove.validateInput('removeAsync', path);\n      // If path not specified defaults to CWD\n      return remove.async(resolvePath(path || '.'));\n    },\n\n    rename: function (path, newName) {\n      rename.validateInput('rename', path, newName);\n      rename.sync(resolvePath(path), newName);\n    },\n    renameAsync: function (path, newName) {\n      rename.validateInput('renameAsync', path, newName);\n      return rename.async(resolvePath(path), newName);\n    },\n\n    symlink: function (symlinkValue, path) {\n      symlink.validateInput('symlink', symlinkValue, path);\n      symlink.sync(symlinkValue, resolvePath(path));\n    },\n    symlinkAsync: function (symlinkValue, path) {\n      symlink.validateInput('symlinkAsync', symlinkValue, path);\n      return symlink.async(symlinkValue, resolvePath(path));\n    },\n\n    write: function (path, data, options) {\n      write.validateInput('write', path, data, options);\n      write.sync(resolvePath(path), data, options);\n    },\n    writeAsync: function (path, data, options) {\n      write.validateInput('writeAsync', path, data, options);\n      return write.async(resolvePath(path), data, options);\n    }\n  };\n\n  if (util.inspect.custom !== undefined) {\n    // Without this console.log(jetpack) throws obscure error. Details:\n    // https://github.com/szwacz/fs-jetpack/issues/29\n    // https://nodejs.org/api/util.html#util_custom_inspection_functions_on_objects\n    api[util.inspect.custom] = function () {\n      return '[fs-jetpack CWD: ' + getCwdPath() + ']';\n    };\n  }\n\n  return api;\n};\n\nmodule.exports = jetpackContext;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/append.js":"'use strict';\n\nvar fs = require('./utils/fs');\nvar write = require('./write');\nvar validate = require('./utils/validate');\n\nvar validateInput = function (methodName, path, data, options) {\n  var methodSignature = methodName + '(path, data, [options])';\n  validate.argument(methodSignature, 'path', path, ['string']);\n  validate.argument(methodSignature, 'data', data, ['string', 'buffer']);\n  validate.options(methodSignature, 'options', options, {\n    mode: ['string', 'number']\n  });\n};\n\n// ---------------------------------------------------------\n// SYNC\n// ---------------------------------------------------------\n\nvar appendSync = function (path, data, options) {\n  try {\n    fs.appendFileSync(path, data, options);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      // Parent directory doesn't exist, so just pass the task to `write`,\n      // which will create the folder and file.\n      write.sync(path, data, options);\n    } else {\n      throw err;\n    }\n  }\n};\n\n// ---------------------------------------------------------\n// ASYNC\n// ---------------------------------------------------------\n\nvar appendAsync = function (path, data, options) {\n  return new Promise(function (resolve, reject) {\n    fs.appendFile(path, data, options)\n    .then(resolve)\n    .catch(function (err) {\n      if (err.code === 'ENOENT') {\n        // Parent directory doesn't exist, so just pass the task to `write`,\n        // which will create the folder and file.\n        write.async(path, data, options).then(resolve, reject);\n      } else {\n        reject(err);\n      }\n    });\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = appendSync;\nexports.async = appendAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/utils/fs.js":"// Adater module exposing all `fs` methods with promises instead of callbacks.\n\n'use strict';\n\nvar fs = require('fs');\nvar promisify = require('./promisify');\n\nvar isCallbackMethod = function (key) {\n  return [\n    typeof fs[key] === 'function',\n    !key.match(/Sync$/),\n    !key.match(/^[A-Z]/),\n    !key.match(/^create/),\n    !key.match(/^(un)?watch/)\n  ].every(Boolean);\n};\n\nvar promisifiedExists = function (path) {\n  return new Promise(function (resolve) {\n    fs.exists(path, function (data) {\n      resolve(data);\n    });\n  });\n};\n\nvar adaptMethod = function (name) {\n  var original = fs[name];\n  return promisify(original);\n};\n\nvar adaptAllMethods = function () {\n  var adapted = {};\n\n  Object.keys(fs).forEach(function (key) {\n    if (isCallbackMethod(key)) {\n      if (key === 'exists') {\n        // fs.exists() does not follow standard\n        // Node callback conventions, and has\n        // no error object in the callback\n        adapted.exists = promisifiedExists;\n      } else {\n        adapted[key] = adaptMethod(key);\n      }\n    } else {\n      adapted[key] = fs[key];\n    }\n  });\n\n  return adapted;\n};\n\nmodule.exports = adaptAllMethods();\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/utils/promisify.js":"'use strict';\n\nmodule.exports = function (fn) {\n  return function () {\n    var i = 0;\n    var length = arguments.length;\n    var args = new Array(length);\n\n    for (; i < length; i++) {\n      args[i] = arguments[i];\n    }\n\n    return new Promise(function (resolve, reject) {\n      args.push(function (err, data) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n\n      fn.apply(null, args);\n    });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/write.js":"'use strict';\n\nvar pathUtil = require('path');\nvar fs = require('./utils/fs');\nvar validate = require('./utils/validate');\nvar dir = require('./dir');\n\nvar validateInput = function (methodName, path, data, options) {\n  var methodSignature = methodName + '(path, data, [options])';\n  validate.argument(methodSignature, 'path', path, ['string']);\n  validate.argument(methodSignature, 'data', data, ['string', 'buffer', 'object', 'array']);\n  validate.options(methodSignature, 'options', options, {\n    atomic: ['boolean'],\n    jsonIndent: ['number']\n  });\n};\n\n// Temporary file extensions used for atomic file overwriting.\nvar newExt = '.__new__';\n\nvar serializeToJsonMaybe = function (data, jsonIndent) {\n  var indent = jsonIndent;\n  if (typeof indent !== 'number') {\n    indent = 2;\n  }\n\n  if (typeof data === 'object'\n      && !Buffer.isBuffer(data)\n      && data !== null) {\n    return JSON.stringify(data, null, indent);\n  }\n\n  return data;\n};\n\n// ---------------------------------------------------------\n// SYNC\n// ---------------------------------------------------------\n\nvar writeFileSync = function (path, data, options) {\n  try {\n    fs.writeFileSync(path, data, options);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      // Means parent directory doesn't exist, so create it and try again.\n      dir.createSync(pathUtil.dirname(path));\n      fs.writeFileSync(path, data, options);\n    } else {\n      throw err;\n    }\n  }\n};\n\nvar writeAtomicSync = function (path, data, options) {\n  // we are assuming there is file on given path, and we don't want\n  // to touch it until we are sure our data has been saved correctly,\n  // so write the data into temporary file...\n  writeFileSync(path + newExt, data, options);\n  // ...next rename temp file to replace real path.\n  fs.renameSync(path + newExt, path);\n};\n\nvar writeSync = function (path, data, options) {\n  var opts = options || {};\n  var processedData = serializeToJsonMaybe(data, opts.jsonIndent);\n\n  var writeStrategy = writeFileSync;\n  if (opts.atomic) {\n    writeStrategy = writeAtomicSync;\n  }\n  writeStrategy(path, processedData, { mode: opts.mode });\n};\n\n// ---------------------------------------------------------\n// ASYNC\n// ---------------------------------------------------------\n\nvar writeFileAsync = function (path, data, options) {\n  return new Promise(function (resolve, reject) {\n    fs.writeFile(path, data, options)\n    .then(resolve)\n    .catch(function (err) {\n      // First attempt to write a file ended with error.\n      // Check if this is not due to nonexistent parent directory.\n      if (err.code === 'ENOENT') {\n        // Parent directory doesn't exist, so create it and try again.\n        dir.createAsync(pathUtil.dirname(path))\n        .then(function () {\n          return fs.writeFile(path, data, options);\n        })\n        .then(resolve, reject);\n      } else {\n        // Nope, some other error, throw it.\n        reject(err);\n      }\n    });\n  });\n};\n\nvar writeAtomicAsync = function (path, data, options) {\n  return new Promise(function (resolve, reject) {\n    // We are assuming there is file on given path, and we don't want\n    // to touch it until we are sure our data has been saved correctly,\n    // so write the data into temporary file...\n    writeFileAsync(path + newExt, data, options)\n    .then(function () {\n      // ...next rename temp file to real path.\n      return fs.rename(path + newExt, path);\n    })\n    .then(resolve, reject);\n  });\n};\n\nvar writeAsync = function (path, data, options) {\n  var opts = options || {};\n  var processedData = serializeToJsonMaybe(data, opts.jsonIndent);\n\n  var writeStrategy = writeFileAsync;\n  if (opts.atomic) {\n    writeStrategy = writeAtomicAsync;\n  }\n  return writeStrategy(path, processedData, { mode: opts.mode });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = writeSync;\nexports.async = writeAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/utils/validate.js":"'use strict';\n\nvar prettyPrintTypes = function (types) {\n  var addArticle = function (str) {\n    var vowels = ['a', 'e', 'i', 'o', 'u'];\n    if (vowels.indexOf(str[0]) !== -1) {\n      return 'an ' + str;\n    }\n    return 'a ' + str;\n  };\n\n  return types.map(addArticle).join(' or ');\n};\n\nvar isArrayOfNotation = function (typeDefinition) {\n  return /array of /.test(typeDefinition);\n};\n\nvar extractTypeFromArrayOfNotation = function (typeDefinition) {\n  // The notation is e.g. 'array of string'\n  return typeDefinition.split(' of ')[1];\n};\n\nvar isValidTypeDefinition = function (typeStr) {\n  if (isArrayOfNotation(typeStr)) {\n    return isValidTypeDefinition(extractTypeFromArrayOfNotation(typeStr));\n  }\n\n  return [\n    'string',\n    'number',\n    'boolean',\n    'array',\n    'object',\n    'buffer',\n    'null',\n    'undefined'\n  ].some(function (validType) {\n    return validType === typeStr;\n  });\n};\n\nvar detectType = function (value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return typeof value;\n};\n\nvar onlyUniqueValuesInArrayFilter = function (value, index, self) {\n  return self.indexOf(value) === index;\n};\n\nvar detectTypeDeep = function (value) {\n  var type = detectType(value);\n  var typesInArray;\n\n  if (type === 'array') {\n    typesInArray = value\n      .map(function (element) {\n        return detectType(element);\n      })\n      .filter(onlyUniqueValuesInArrayFilter);\n    type += ' of ' + typesInArray.join(', ');\n  }\n\n  return type;\n};\n\nvar validateArray = function (argumentValue, typeToCheck) {\n  var allowedTypeInArray = extractTypeFromArrayOfNotation(typeToCheck);\n\n  if (detectType(argumentValue) !== 'array') {\n    return false;\n  }\n\n  return argumentValue.every(function (element) {\n    return detectType(element) === allowedTypeInArray;\n  });\n};\n\nvar validateArgument = function (methodName, argumentName, argumentValue, argumentMustBe) {\n  var isOneOfAllowedTypes = argumentMustBe.some(function (type) {\n    if (!isValidTypeDefinition(type)) {\n      throw new Error('Unknown type \"' + type + '\"');\n    }\n\n    if (isArrayOfNotation(type)) {\n      return validateArray(argumentValue, type);\n    }\n\n    return type === detectType(argumentValue);\n  });\n\n  if (!isOneOfAllowedTypes) {\n    throw new Error('Argument \"' + argumentName + '\" passed to ' + methodName + ' must be '\n      + prettyPrintTypes(argumentMustBe) + '. Received ' + detectTypeDeep(argumentValue));\n  }\n};\n\nvar validateOptions = function (methodName, optionsObjName, obj, allowedOptions) {\n  if (obj !== undefined) {\n    validateArgument(methodName, optionsObjName, obj, ['object']);\n    Object.keys(obj).forEach(function (key) {\n      var argName = optionsObjName + '.' + key;\n      if (allowedOptions.hasOwnProperty(key)) {\n        validateArgument(methodName, argName, obj[key], allowedOptions[key]);\n      } else {\n        throw new Error('Unknown argument \"' + argName + '\" passed to ' + methodName);\n      }\n    });\n  }\n};\n\nmodule.exports = {\n  argument: validateArgument,\n  options: validateOptions\n};\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/dir.js":"'use strict';\n\nvar pathUtil = require('path');\nvar fs = require('./utils/fs');\nvar modeUtil = require('./utils/mode');\nvar validate = require('./utils/validate');\nvar remove = require('./remove');\n\nvar validateInput = function (methodName, path, criteria) {\n  var methodSignature = methodName + '(path, [criteria])';\n  validate.argument(methodSignature, 'path', path, ['string']);\n  validate.options(methodSignature, 'criteria', criteria, {\n    empty: ['boolean'],\n    mode: ['string', 'number']\n  });\n};\n\nvar getCriteriaDefaults = function (passedCriteria) {\n  var criteria = passedCriteria || {};\n  if (typeof criteria.empty !== 'boolean') {\n    criteria.empty = false;\n  }\n  if (criteria.mode !== undefined) {\n    criteria.mode = modeUtil.normalizeFileMode(criteria.mode);\n  }\n  return criteria;\n};\n\nvar generatePathOccupiedByNotDirectoryError = function (path) {\n  return new Error('Path ' + path + ' exists but is not a directory.' +\n      ' Halting jetpack.dir() call for safety reasons.');\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar checkWhatAlreadyOccupiesPathSync = function (path) {\n  var stat;\n\n  try {\n    stat = fs.statSync(path);\n  } catch (err) {\n    // Detection if path already exists\n    if (err.code !== 'ENOENT') {\n      throw err;\n    }\n  }\n\n  if (stat && !stat.isDirectory()) {\n    throw generatePathOccupiedByNotDirectoryError(path);\n  }\n\n  return stat;\n};\n\nvar createBrandNewDirectorySync = function (path, opts) {\n  var options = opts || {};\n\n  try {\n    fs.mkdirSync(path, options.mode);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      // Parent directory doesn't exist. Need to create it first.\n      createBrandNewDirectorySync(pathUtil.dirname(path), options);\n      // Now retry creating this directory.\n      fs.mkdirSync(path, options.mode);\n    } else if (err.code === 'EEXIST') {\n      // The path already exists. We're fine.\n    } else {\n      throw err;\n    }\n  }\n};\n\nvar checkExistingDirectoryFulfillsCriteriaSync = function (path, stat, criteria) {\n  var checkMode = function () {\n    var mode = modeUtil.normalizeFileMode(stat.mode);\n    if (criteria.mode !== undefined && criteria.mode !== mode) {\n      fs.chmodSync(path, criteria.mode);\n    }\n  };\n\n  var checkEmptiness = function () {\n    var list;\n    if (criteria.empty) {\n      // Delete everything inside this directory\n      list = fs.readdirSync(path);\n      list.forEach(function (filename) {\n        remove.sync(pathUtil.resolve(path, filename));\n      });\n    }\n  };\n\n  checkMode();\n  checkEmptiness();\n};\n\nvar dirSync = function (path, passedCriteria) {\n  var criteria = getCriteriaDefaults(passedCriteria);\n  var stat = checkWhatAlreadyOccupiesPathSync(path);\n  if (stat) {\n    checkExistingDirectoryFulfillsCriteriaSync(path, stat, criteria);\n  } else {\n    createBrandNewDirectorySync(path, criteria);\n  }\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar checkWhatAlreadyOccupiesPathAsync = function (path) {\n  return new Promise(function (resolve, reject) {\n    fs.stat(path)\n    .then(function (stat) {\n      if (stat.isDirectory()) {\n        resolve(stat);\n      } else {\n        reject(generatePathOccupiedByNotDirectoryError(path));\n      }\n    })\n    .catch(function (err) {\n      if (err.code === 'ENOENT') {\n        // Path doesn't exist\n        resolve(undefined);\n      } else {\n        // This is other error that nonexistent path, so end here.\n        reject(err);\n      }\n    });\n  });\n};\n\n// Delete all files and directores inside given directory\nvar emptyAsync = function (path) {\n  return new Promise(function (resolve, reject) {\n    fs.readdir(path)\n    .then(function (list) {\n      var doOne = function (index) {\n        var subPath;\n        if (index === list.length) {\n          resolve();\n        } else {\n          subPath = pathUtil.resolve(path, list[index]);\n          remove.async(subPath).then(function () {\n            doOne(index + 1);\n          });\n        }\n      };\n\n      doOne(0);\n    })\n    .catch(reject);\n  });\n};\n\nvar checkExistingDirectoryFulfillsCriteriaAsync = function (path, stat, criteria) {\n  return new Promise(function (resolve, reject) {\n    var checkMode = function () {\n      var mode = modeUtil.normalizeFileMode(stat.mode);\n      if (criteria.mode !== undefined && criteria.mode !== mode) {\n        return fs.chmod(path, criteria.mode);\n      }\n      return Promise.resolve();\n    };\n\n    var checkEmptiness = function () {\n      if (criteria.empty) {\n        return emptyAsync(path);\n      }\n      return Promise.resolve();\n    };\n\n    checkMode()\n    .then(checkEmptiness)\n    .then(resolve, reject);\n  });\n};\n\nvar createBrandNewDirectoryAsync = function (path, opts) {\n  var options = opts || {};\n\n  return new Promise(function (resolve, reject) {\n    fs.mkdir(path, options.mode)\n    .then(resolve)\n    .catch(function (err) {\n      if (err.code === 'ENOENT') {\n        // Parent directory doesn't exist. Need to create it first.\n        createBrandNewDirectoryAsync(pathUtil.dirname(path), options)\n        .then(function () {\n          // Now retry creating this directory.\n          return fs.mkdir(path, options.mode);\n        })\n        .then(resolve)\n        .catch(function (err2) {\n          if (err2.code === 'EEXIST') {\n            // Hmm, something other have already created the directory?\n            // No problem for us.\n            resolve();\n          } else {\n            reject(err2);\n          }\n        });\n      } else if (err.code === 'EEXIST') {\n        // The path already exists. We're fine.\n        resolve();\n      } else {\n        reject(err);\n      }\n    });\n  });\n};\n\nvar dirAsync = function (path, passedCriteria) {\n  return new Promise(function (resolve, reject) {\n    var criteria = getCriteriaDefaults(passedCriteria);\n\n    checkWhatAlreadyOccupiesPathAsync(path)\n    .then(function (stat) {\n      if (stat !== undefined) {\n        return checkExistingDirectoryFulfillsCriteriaAsync(path, stat, criteria);\n      }\n      return createBrandNewDirectoryAsync(path, criteria);\n    })\n    .then(resolve, reject);\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = dirSync;\nexports.createSync = createBrandNewDirectorySync;\nexports.async = dirAsync;\nexports.createAsync = createBrandNewDirectoryAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/utils/mode.js":"// Logic for unix file mode operations.\n\n'use strict';\n\n// Converts mode to string 3 characters long.\nexports.normalizeFileMode = function (mode) {\n  var modeAsString;\n  if (typeof mode === 'number') {\n    modeAsString = mode.toString(8);\n  } else {\n    modeAsString = mode;\n  }\n  return modeAsString.substring(modeAsString.length - 3);\n};\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/remove.js":"'use strict';\n\nvar pathUtil = require('path');\nvar fs = require('./utils/fs');\nvar validate = require('./utils/validate');\nvar list = require('./list');\n\nvar validateInput = function (methodName, path) {\n  var methodSignature = methodName + '([path])';\n  validate.argument(methodSignature, 'path', path, ['string', 'undefined']);\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar removeSync = function (path) {\n  try {\n    // Assume the path is a file and just try to remove it.\n    fs.unlinkSync(path);\n  } catch (err) {\n    if (err.code === 'EPERM' || err.code === 'EISDIR' || err.code === 'ENOTEMPTY') {\n      // Must delete everything inside the directory first.\n      list.sync(path).forEach(function (filename) {\n        removeSync(pathUtil.join(path, filename));\n      });\n      // Everything inside directory has been removed,\n      // it's safe now do go for the directory itself.\n      fs.rmdirSync(path);\n    } else if (err.code === 'ENOENT') {\n      // File already doesn't exist. We're done.\n    } else {\n      // Something unexpected happened. Rethrow original error.\n      throw err;\n    }\n  }\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar removeAsyncInternal = function (path, retryCount) {\n  return new Promise(function (resolve, reject) {\n    var retryInAWhileOrFail = function (err) {\n      if (retryCount === 3) {\n        // Too many retries already. Fail.\n        reject(err);\n      } else {\n        // Try the same action after some pause.\n        setTimeout(function () {\n          removeAsyncInternal(path, retryCount + 1)\n          .then(resolve, reject);\n        }, 100);\n      }\n    };\n\n    var removeEverythingInsideDirectory = function () {\n      return list.async(path)\n      .then(function (filenamesInsideDir) {\n        var promises = filenamesInsideDir.map(function (filename) {\n          return removeAsyncInternal(pathUtil.join(path, filename), 0);\n        });\n        return Promise.all(promises);\n      });\n    };\n\n    // Assume the path is a file and just try to remove it.\n    fs.unlink(path)\n    .then(resolve)\n    .catch(function (err) {\n      if (err.code === 'EBUSY') {\n        retryInAWhileOrFail(err);\n      } else if (err.code === 'EPERM' || err.code === 'EISDIR' || err.code === 'ENOTEMPTY') {\n        // File deletion attempt failed. Probably it's not a file, it's a directory.\n        // So try to proceed with that assumption.\n        removeEverythingInsideDirectory()\n        .then(function () {\n          // Now go for the directory.\n          return fs.rmdir(path);\n        })\n        .then(resolve)\n        .catch(function (err2) {\n          if (err2.code === 'EBUSY' || err2.code === 'EPERM' || err2.code === 'ENOTEMPTY') {\n            // Failed again. This might be due to other processes reading\n            // something inside the directory. Let's take a nap and retry.\n            retryInAWhileOrFail(err2);\n          } else {\n            reject(err2);\n          }\n        });\n      } else if (err.code === 'ENOENT') {\n        // File already doesn't exist. We're done.\n        resolve();\n      } else {\n        // Something unexpected happened. Rethrow original error.\n        reject(err);\n      }\n    });\n  });\n};\n\nvar removeAsync = function (path) {\n  return removeAsyncInternal(path, 0);\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = removeSync;\nexports.async = removeAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/list.js":"'use strict';\n\nvar fs = require('./utils/fs');\nvar validate = require('./utils/validate');\n\nvar validateInput = function (methodName, path) {\n  var methodSignature = methodName + '(path)';\n  validate.argument(methodSignature, 'path', path, ['string', 'undefined']);\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar listSync = function (path) {\n  try {\n    return fs.readdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      // Doesn't exist. Return undefined instead of throwing.\n      return undefined;\n    }\n    throw err;\n  }\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar listAsync = function (path) {\n  return new Promise(function (resolve, reject) {\n    fs.readdir(path)\n    .then(function (list) {\n      resolve(list);\n    })\n    .catch(function (err) {\n      if (err.code === 'ENOENT') {\n        // Doesn't exist. Return undefined instead of throwing.\n        resolve(undefined);\n      } else {\n        reject(err);\n      }\n    });\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = listSync;\nexports.async = listAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/file.js":"'use strict';\n\nvar fs = require('./utils/fs');\nvar modeUtil = require('./utils/mode');\nvar validate = require('./utils/validate');\nvar write = require('./write');\n\nvar validateInput = function (methodName, path, criteria) {\n  var methodSignature = methodName + '(path, [criteria])';\n  validate.argument(methodSignature, 'path', path, ['string']);\n  validate.options(methodSignature, 'criteria', criteria, {\n    content: ['string', 'buffer', 'object', 'array'],\n    jsonIndent: ['number'],\n    mode: ['string', 'number']\n  });\n};\n\nvar getCriteriaDefaults = function (passedCriteria) {\n  var criteria = passedCriteria || {};\n  if (criteria.mode !== undefined) {\n    criteria.mode = modeUtil.normalizeFileMode(criteria.mode);\n  }\n  return criteria;\n};\n\nvar generatePathOccupiedByNotFileError = function (path) {\n  return new Error('Path ' + path + ' exists but is not a file.' +\n      ' Halting jetpack.file() call for safety reasons.');\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar checkWhatAlreadyOccupiesPathSync = function (path) {\n  var stat;\n\n  try {\n    stat = fs.statSync(path);\n  } catch (err) {\n    // Detection if path exists\n    if (err.code !== 'ENOENT') {\n      throw err;\n    }\n  }\n\n  if (stat && !stat.isFile()) {\n    throw generatePathOccupiedByNotFileError(path);\n  }\n\n  return stat;\n};\n\nvar checkExistingFileFulfillsCriteriaSync = function (path, stat, criteria) {\n  var mode = modeUtil.normalizeFileMode(stat.mode);\n\n  var checkContent = function () {\n    if (criteria.content !== undefined) {\n      write.sync(path, criteria.content, {\n        mode: mode,\n        jsonIndent: criteria.jsonIndent\n      });\n      return true;\n    }\n    return false;\n  };\n\n  var checkMode = function () {\n    if (criteria.mode !== undefined && criteria.mode !== mode) {\n      fs.chmodSync(path, criteria.mode);\n    }\n  };\n\n  var contentReplaced = checkContent();\n  if (!contentReplaced) {\n    checkMode();\n  }\n};\n\nvar createBrandNewFileSync = function (path, criteria) {\n  var content = '';\n  if (criteria.content !== undefined) {\n    content = criteria.content;\n  }\n  write.sync(path, content, {\n    mode: criteria.mode,\n    jsonIndent: criteria.jsonIndent\n  });\n};\n\nvar fileSync = function (path, passedCriteria) {\n  var criteria = getCriteriaDefaults(passedCriteria);\n  var stat = checkWhatAlreadyOccupiesPathSync(path);\n  if (stat !== undefined) {\n    checkExistingFileFulfillsCriteriaSync(path, stat, criteria);\n  } else {\n    createBrandNewFileSync(path, criteria);\n  }\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar checkWhatAlreadyOccupiesPathAsync = function (path) {\n  return new Promise(function (resolve, reject) {\n    fs.stat(path)\n    .then(function (stat) {\n      if (stat.isFile()) {\n        resolve(stat);\n      } else {\n        reject(generatePathOccupiedByNotFileError(path));\n      }\n    })\n    .catch(function (err) {\n      if (err.code === 'ENOENT') {\n        // Path doesn't exist.\n        resolve(undefined);\n      } else {\n        // This is other error. Must end here.\n        reject(err);\n      }\n    });\n  });\n};\n\nvar checkExistingFileFulfillsCriteriaAsync = function (path, stat, criteria) {\n  var mode = modeUtil.normalizeFileMode(stat.mode);\n\n  var checkContent = function () {\n    return new Promise(function (resolve, reject) {\n      if (criteria.content !== undefined) {\n        write.async(path, criteria.content, {\n          mode: mode,\n          jsonIndent: criteria.jsonIndent\n        })\n        .then(function () {\n          resolve(true);\n        })\n        .catch(reject);\n      } else {\n        resolve(false);\n      }\n    });\n  };\n\n  var checkMode = function () {\n    if (criteria.mode !== undefined && criteria.mode !== mode) {\n      return fs.chmod(path, criteria.mode);\n    }\n    return undefined;\n  };\n\n  return checkContent()\n  .then(function (contentReplaced) {\n    if (!contentReplaced) {\n      return checkMode();\n    }\n    return undefined;\n  });\n};\n\nvar createBrandNewFileAsync = function (path, criteria) {\n  var content = '';\n  if (criteria.content !== undefined) {\n    content = criteria.content;\n  }\n\n  return write.async(path, content, {\n    mode: criteria.mode,\n    jsonIndent: criteria.jsonIndent\n  });\n};\n\nvar fileAsync = function (path, passedCriteria) {\n  return new Promise(function (resolve, reject) {\n    var criteria = getCriteriaDefaults(passedCriteria);\n\n    checkWhatAlreadyOccupiesPathAsync(path)\n    .then(function (stat) {\n      if (stat !== undefined) {\n        return checkExistingFileFulfillsCriteriaAsync(path, stat, criteria);\n      }\n      return createBrandNewFileAsync(path, criteria);\n    })\n    .then(resolve, reject);\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = fileSync;\nexports.async = fileAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/find.js":"'use strict';\n\nvar pathUtil = require('path');\nvar treeWalker = require('./utils/tree_walker');\nvar inspect = require('./inspect');\nvar matcher = require('./utils/matcher');\nvar validate = require('./utils/validate');\n\nvar validateInput = function (methodName, path, options) {\n  var methodSignature = methodName + '([path], options)';\n  validate.argument(methodSignature, 'path', path, ['string']);\n  validate.options(methodSignature, 'options', options, {\n    matching: ['string', 'array of string'],\n    files: ['boolean'],\n    directories: ['boolean'],\n    recursive: ['boolean']\n  });\n};\n\nvar normalizeOptions = function (options) {\n  var opts = options || {};\n  // defaults:\n  if (opts.files === undefined) {\n    opts.files = true;\n  }\n  if (opts.directories === undefined) {\n    opts.directories = false;\n  }\n  if (opts.recursive === undefined) {\n    opts.recursive = true;\n  }\n  return opts;\n};\n\nvar processFoundObjects = function (foundObjects, cwd) {\n  return foundObjects.map(function (inspectObj) {\n    return pathUtil.relative(cwd, inspectObj.absolutePath);\n  });\n};\n\nvar generatePathDoesntExistError = function (path) {\n  var err = new Error(\"Path you want to find stuff in doesn't exist \" + path);\n  err.code = 'ENOENT';\n  return err;\n};\n\nvar generatePathNotDirectoryError = function (path) {\n  var err = new Error('Path you want to find stuff in must be a directory ' + path);\n  err.code = 'ENOTDIR';\n  return err;\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar findSync = function (path, options) {\n  var foundInspectObjects = [];\n  var matchesAnyOfGlobs = matcher.create(path, options.matching);\n\n  treeWalker.sync(path, {\n    maxLevelsDeep: options.recursive ? Infinity : 1,\n    inspectOptions: {\n      absolutePath: true\n    }\n  }, function (itemPath, item) {\n    if (itemPath !== path && matchesAnyOfGlobs(itemPath)) {\n      if ((item.type === 'file' && options.files === true)\n        || (item.type === 'dir' && options.directories === true)) {\n        foundInspectObjects.push(item);\n      }\n    }\n  });\n\n  return processFoundObjects(foundInspectObjects, options.cwd);\n};\n\nvar findSyncInit = function (path, options) {\n  var entryPointInspect = inspect.sync(path);\n  if (entryPointInspect === undefined) {\n    throw generatePathDoesntExistError(path);\n  } else if (entryPointInspect.type !== 'dir') {\n    throw generatePathNotDirectoryError(path);\n  }\n\n  return findSync(path, normalizeOptions(options));\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar findAsync = function (path, options) {\n  return new Promise(function (resolve, reject) {\n    var foundInspectObjects = [];\n    var matchesAnyOfGlobs = matcher.create(path, options.matching);\n\n    var walker = treeWalker.stream(path, {\n      maxLevelsDeep: options.recursive ? Infinity : 1,\n      inspectOptions: {\n        absolutePath: true\n      }\n    })\n    .on('readable', function () {\n      var data = walker.read();\n      var item;\n      if (data && data.path !== path && matchesAnyOfGlobs(data.path)) {\n        item = data.item;\n        if ((item.type === 'file' && options.files === true)\n          || (item.type === 'dir' && options.directories === true)) {\n          foundInspectObjects.push(item);\n        }\n      }\n    })\n    .on('error', reject)\n    .on('end', function () {\n      resolve(processFoundObjects(foundInspectObjects, options.cwd));\n    });\n  });\n};\n\nvar findAsyncInit = function (path, options) {\n  return inspect.async(path)\n  .then(function (entryPointInspect) {\n    if (entryPointInspect === undefined) {\n      throw generatePathDoesntExistError(path);\n    } else if (entryPointInspect.type !== 'dir') {\n      throw generatePathNotDirectoryError(path);\n    }\n    return findAsync(path, normalizeOptions(options));\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = findSyncInit;\nexports.async = findAsyncInit;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/utils/tree_walker.js":"/* eslint no-underscore-dangle:0 */\n\n'use strict';\n\nvar Readable = require('stream').Readable;\nvar pathUtil = require('path');\nvar inspect = require('../inspect');\nvar list = require('../list');\n\n// ---------------------------------------------------------\n// SYNC\n// ---------------------------------------------------------\n\nvar walkSync = function (path, options, callback, currentLevel) {\n  var item = inspect.sync(path, options.inspectOptions);\n\n  if (options.maxLevelsDeep === undefined) {\n    options.maxLevelsDeep = Infinity;\n  }\n  if (currentLevel === undefined) {\n    currentLevel = 0;\n  }\n\n  callback(path, item);\n  if (item && item.type === 'dir' && currentLevel < options.maxLevelsDeep) {\n    list.sync(path).forEach(function (child) {\n      walkSync(path + pathUtil.sep + child, options, callback, currentLevel + 1);\n    });\n  }\n};\n\n// ---------------------------------------------------------\n// STREAM\n// ---------------------------------------------------------\n\nvar walkStream = function (path, options) {\n  var rs = new Readable({ objectMode: true });\n  var nextTreeNode = {\n    path: path,\n    parent: undefined,\n    level: 0\n  };\n  var running = false;\n  var readSome;\n\n  var error = function (err) {\n    rs.emit('error', err);\n  };\n\n  var findNextUnprocessedNode = function (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    } else if (node.parent) {\n      return findNextUnprocessedNode(node.parent);\n    }\n    return undefined;\n  };\n\n  var pushAndContinueMaybe = function (data) {\n    var theyWantMore = rs.push(data);\n    running = false;\n    if (!nextTreeNode) {\n      // Previous was the last node. The job is done.\n      rs.push(null);\n    } else if (theyWantMore) {\n      readSome();\n    }\n  };\n\n  if (options.maxLevelsDeep === undefined) {\n    options.maxLevelsDeep = Infinity;\n  }\n\n  readSome = function () {\n    var theNode = nextTreeNode;\n\n    running = true;\n\n    inspect.async(theNode.path, options.inspectOptions)\n    .then(function (inspected) {\n      theNode.inspected = inspected;\n      if (inspected && inspected.type === 'dir' && theNode.level < options.maxLevelsDeep) {\n        list.async(theNode.path)\n        .then(function (childrenNames) {\n          var children = childrenNames.map(function (name) {\n            return {\n              name: name,\n              path: theNode.path + pathUtil.sep + name,\n              parent: theNode,\n              level: theNode.level + 1\n            };\n          });\n          children.forEach(function (child, index) {\n            child.nextSibling = children[index + 1];\n          });\n\n          nextTreeNode = children[0] || findNextUnprocessedNode(theNode);\n          pushAndContinueMaybe({ path: theNode.path, item: inspected });\n        })\n        .catch(error);\n      } else {\n        nextTreeNode = findNextUnprocessedNode(theNode);\n        pushAndContinueMaybe({ path: theNode.path, item: inspected });\n      }\n    })\n    .catch(error);\n  };\n\n  rs._read = function () {\n    if (!running) {\n      readSome();\n    }\n  };\n\n  return rs;\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.sync = walkSync;\nexports.stream = walkStream;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/inspect.js":"'use strict';\n\nvar crypto = require('crypto');\nvar pathUtil = require('path');\nvar fs = require('./utils/fs');\nvar validate = require('./utils/validate');\n\nvar supportedChecksumAlgorithms = ['md5', 'sha1', 'sha256', 'sha512'];\n\nvar symlinkOptions = ['report', 'follow'];\n\nvar validateInput = function (methodName, path, options) {\n  var methodSignature = methodName + '(path, [options])';\n  validate.argument(methodSignature, 'path', path, ['string']);\n  validate.options(methodSignature, 'options', options, {\n    checksum: ['string'],\n    mode: ['boolean'],\n    times: ['boolean'],\n    absolutePath: ['boolean'],\n    symlinks: ['string']\n  });\n\n  if (options && options.checksum !== undefined\n    && supportedChecksumAlgorithms.indexOf(options.checksum) === -1) {\n    throw new Error('Argument \"options.checksum\" passed to ' + methodSignature\n      + ' must have one of values: ' + supportedChecksumAlgorithms.join(', '));\n  }\n\n  if (options && options.symlinks !== undefined\n    && symlinkOptions.indexOf(options.symlinks) === -1) {\n    throw new Error('Argument \"options.symlinks\" passed to ' + methodSignature\n      + ' must have one of values: ' + symlinkOptions.join(', '));\n  }\n};\n\nvar createInspectObj = function (path, options, stat) {\n  var obj = {};\n\n  obj.name = pathUtil.basename(path);\n\n  if (stat.isFile()) {\n    obj.type = 'file';\n    obj.size = stat.size;\n  } else if (stat.isDirectory()) {\n    obj.type = 'dir';\n  } else if (stat.isSymbolicLink()) {\n    obj.type = 'symlink';\n  } else {\n    obj.type = 'other';\n  }\n\n  if (options.mode) {\n    obj.mode = stat.mode;\n  }\n\n  if (options.times) {\n    obj.accessTime = stat.atime;\n    obj.modifyTime = stat.mtime;\n    obj.changeTime = stat.ctime;\n  }\n\n  if (options.absolutePath) {\n    obj.absolutePath = path;\n  }\n\n  return obj;\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar fileChecksum = function (path, algo) {\n  var hash = crypto.createHash(algo);\n  var data = fs.readFileSync(path);\n  hash.update(data);\n  return hash.digest('hex');\n};\n\nvar addExtraFieldsSync = function (path, inspectObj, options) {\n  if (inspectObj.type === 'file' && options.checksum) {\n    inspectObj[options.checksum] = fileChecksum(path, options.checksum);\n  } else if (inspectObj.type === 'symlink') {\n    inspectObj.pointsAt = fs.readlinkSync(path);\n  }\n};\n\nvar inspectSync = function (path, options) {\n  var statOperation = fs.lstatSync;\n  var stat;\n  var inspectObj;\n  options = options || {};\n\n  if (options.symlinks === 'follow') {\n    statOperation = fs.statSync;\n  }\n\n  try {\n    stat = statOperation(path);\n  } catch (err) {\n    // Detection if path exists\n    if (err.code === 'ENOENT') {\n      // Doesn't exist. Return undefined instead of throwing.\n      return undefined;\n    }\n    throw err;\n  }\n\n  inspectObj = createInspectObj(path, options, stat);\n  addExtraFieldsSync(path, inspectObj, options);\n\n  return inspectObj;\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar fileChecksumAsync = function (path, algo) {\n  return new Promise(function (resolve, reject) {\n    var hash = crypto.createHash(algo);\n    var s = fs.createReadStream(path);\n    s.on('data', function (data) {\n      hash.update(data);\n    });\n    s.on('end', function () {\n      resolve(hash.digest('hex'));\n    });\n    s.on('error', reject);\n  });\n};\n\nvar addExtraFieldsAsync = function (path, inspectObj, options) {\n  if (inspectObj.type === 'file' && options.checksum) {\n    return fileChecksumAsync(path, options.checksum)\n    .then(function (checksum) {\n      inspectObj[options.checksum] = checksum;\n      return inspectObj;\n    });\n  } else if (inspectObj.type === 'symlink') {\n    return fs.readlink(path)\n    .then(function (linkPath) {\n      inspectObj.pointsAt = linkPath;\n      return inspectObj;\n    });\n  }\n  return Promise.resolve(inspectObj);\n};\n\nvar inspectAsync = function (path, options) {\n  return new Promise(function (resolve, reject) {\n    var statOperation = fs.lstat;\n    options = options || {};\n\n    if (options.symlinks === 'follow') {\n      statOperation = fs.stat;\n    }\n\n    statOperation(path)\n    .then(function (stat) {\n      var inspectObj = createInspectObj(path, options, stat);\n      addExtraFieldsAsync(path, inspectObj, options)\n      .then(resolve, reject);\n    })\n    .catch(function (err) {\n      // Detection if path exists\n      if (err.code === 'ENOENT') {\n        // Doesn't exist. Return undefined instead of throwing.\n        resolve(undefined);\n      } else {\n        reject(err);\n      }\n    });\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.supportedChecksumAlgorithms = supportedChecksumAlgorithms;\nexports.symlinkOptions = symlinkOptions;\nexports.validateInput = validateInput;\nexports.sync = inspectSync;\nexports.async = inspectAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/utils/matcher.js":"'use strict';\n\nvar Minimatch = require('minimatch').Minimatch;\n\nvar convertPatternToAbsolutePath = function (basePath, pattern) {\n  // All patterns without slash are left as they are, if pattern contain\n  // any slash we need to turn it into absolute path.\n  var hasSlash = (pattern.indexOf('/') !== -1);\n  var isAbsolute = /^!?\\//.test(pattern);\n  var isNegated = /^!/.test(pattern);\n  var separator;\n\n  if (!isAbsolute && hasSlash) {\n    // Throw out meaningful characters from the beginning (\"!\", \"./\").\n    pattern = pattern.replace(/^!/, '').replace(/^\\.\\//, '');\n\n    if (/\\/$/.test(basePath)) {\n      separator = '';\n    } else {\n      separator = '/';\n    }\n\n    if (isNegated) {\n      return '!' + basePath + separator + pattern;\n    }\n    return basePath + separator + pattern;\n  }\n\n  return pattern;\n};\n\nexports.create = function (basePath, patterns) {\n  var matchers;\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  matchers = patterns.map(function (pattern) {\n    return convertPatternToAbsolutePath(basePath, pattern);\n  })\n  .map(function (pattern) {\n    return new Minimatch(pattern, {\n      matchBase: true,\n      nocomment: true,\n      dot: true\n    });\n  });\n\n  return function performMatch(absolutePath) {\n    var mode = 'matching';\n    var weHaveMatch = false;\n    var currentMatcher;\n    var i;\n\n    for (i = 0; i < matchers.length; i += 1) {\n      currentMatcher = matchers[i];\n\n      if (currentMatcher.negate) {\n        mode = 'negation';\n        if (i === 0) {\n          // There are only negated patterns in the set,\n          // so make everything matching by default and\n          // start to reject stuff.\n          weHaveMatch = true;\n        }\n      }\n\n      if (mode === 'negation' && weHaveMatch && !currentMatcher.match(absolutePath)) {\n        // One negation match is enought to know we can reject this one.\n        return false;\n      }\n\n      if (mode === 'matching' && !weHaveMatch) {\n        weHaveMatch = currentMatcher.match(absolutePath);\n      }\n    }\n\n    return weHaveMatch;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/inspect_tree.js":"'use strict';\n\nvar crypto = require('crypto');\nvar pathUtil = require('path');\nvar inspect = require('./inspect');\nvar list = require('./list');\nvar validate = require('./utils/validate');\n\nvar validateInput = function (methodName, path, options) {\n  var methodSignature = methodName + '(path, [options])';\n  validate.argument(methodSignature, 'path', path, ['string']);\n  validate.options(methodSignature, 'options', options, {\n    checksum: ['string'],\n    relativePath: ['boolean'],\n    symlinks: ['string']\n  });\n\n  if (options && options.checksum !== undefined\n    && inspect.supportedChecksumAlgorithms.indexOf(options.checksum) === -1) {\n    throw new Error('Argument \"options.checksum\" passed to ' + methodSignature\n      + ' must have one of values: ' + inspect.supportedChecksumAlgorithms.join(', '));\n  }\n\n  if (options && options.symlinks !== undefined\n    && inspect.symlinkOptions.indexOf(options.symlinks) === -1) {\n    throw new Error('Argument \"options.symlinks\" passed to ' + methodSignature\n      + ' must have one of values: ' + inspect.symlinkOptions.join(', '));\n  }\n};\n\nvar generateTreeNodeRelativePath = function (parent, path) {\n  if (!parent) {\n    return '.';\n  }\n  return parent.relativePath + '/' + pathUtil.basename(path);\n};\n\n// Creates checksum of a directory by using\n// checksums and names of all its children inside.\nvar checksumOfDir = function (inspectList, algo) {\n  var hash = crypto.createHash(algo);\n  inspectList.forEach(function (inspectObj) {\n    hash.update(inspectObj.name + inspectObj[algo]);\n  });\n  return hash.digest('hex');\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar inspectTreeNodeSync = function (path, options, parent) {\n  var treeBranch = inspect.sync(path, options);\n\n  if (treeBranch) {\n    if (options.relativePath) {\n      treeBranch.relativePath = generateTreeNodeRelativePath(parent, path);\n    }\n\n    if (treeBranch.type === 'dir') {\n      treeBranch.size = 0;\n      treeBranch.children = list.sync(path).map(function (filename) {\n        var subBranchPath = pathUtil.join(path, filename);\n        var treeSubBranch = inspectTreeNodeSync(subBranchPath, options, treeBranch);\n        // Add together all childrens' size to get directory combined size.\n        treeBranch.size += treeSubBranch.size || 0;\n        return treeSubBranch;\n      });\n\n      if (options.checksum) {\n        treeBranch[options.checksum] = checksumOfDir(treeBranch.children, options.checksum);\n      }\n    }\n  }\n\n  return treeBranch;\n};\n\nvar inspectTreeSync = function (path, options) {\n  options = options || {};\n\n  return inspectTreeNodeSync(path, options, undefined);\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar inspectTreeNodeAsync = function (path, options, parent) {\n  return new Promise(function (resolve, reject) {\n    var inspectAllChildren = function (treeBranch) {\n      return new Promise(function (resolve2, reject2) {\n        list.async(path).then(function (children) {\n          var doNext = function (index) {\n            var subPath;\n            if (index === children.length) {\n              if (options.checksum) {\n                // We are done, but still have to calculate checksum of whole directory.\n                treeBranch[options.checksum] = checksumOfDir(treeBranch.children, options.checksum);\n              }\n              resolve2();\n            } else {\n              subPath = pathUtil.join(path, children[index]);\n              inspectTreeNodeAsync(subPath, options, treeBranch)\n              .then(function (treeSubBranch) {\n                children[index] = treeSubBranch;\n                treeBranch.size += treeSubBranch.size || 0;\n                doNext(index + 1);\n              })\n              .catch(reject2);\n            }\n          };\n\n          treeBranch.children = children;\n          treeBranch.size = 0;\n\n          doNext(0);\n        });\n      });\n    };\n\n    inspect.async(path, options)\n    .then(function (treeBranch) {\n      if (!treeBranch) {\n        // Given path doesn't exist. We are done.\n        resolve(treeBranch);\n      } else {\n        if (options.relativePath) {\n          treeBranch.relativePath = generateTreeNodeRelativePath(parent, path);\n        }\n\n        if (treeBranch.type !== 'dir') {\n          resolve(treeBranch);\n        } else {\n          inspectAllChildren(treeBranch)\n          .then(function () {\n            resolve(treeBranch);\n          })\n          .catch(reject);\n        }\n      }\n    })\n    .catch(reject);\n  });\n};\n\nvar inspectTreeAsync = function (path, options) {\n  options = options || {};\n\n  return inspectTreeNodeAsync(path, options);\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = inspectTreeSync;\nexports.async = inspectTreeAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/copy.js":"'use strict';\n\nvar pathUtil = require('path');\nvar fs = require('./utils/fs');\nvar dir = require('./dir');\nvar exists = require('./exists');\nvar matcher = require('./utils/matcher');\nvar fileMode = require('./utils/mode');\nvar treeWalker = require('./utils/tree_walker');\nvar validate = require('./utils/validate');\nvar write = require('./write');\n\nvar validateInput = function (methodName, from, to, options) {\n  var methodSignature = methodName + '(from, to, [options])';\n  validate.argument(methodSignature, 'from', from, ['string']);\n  validate.argument(methodSignature, 'to', to, ['string']);\n  validate.options(methodSignature, 'options', options, {\n    overwrite: ['boolean'],\n    matching: ['string', 'array of string']\n  });\n};\n\nvar parseOptions = function (options, from) {\n  var opts = options || {};\n  var parsedOptions = {};\n\n  parsedOptions.overwrite = opts.overwrite;\n\n  if (opts.matching) {\n    parsedOptions.allowedToCopy = matcher.create(from, opts.matching);\n  } else {\n    parsedOptions.allowedToCopy = function () {\n      // Default behaviour - copy everything.\n      return true;\n    };\n  }\n\n  return parsedOptions;\n};\n\nvar generateNoSourceError = function (path) {\n  var err = new Error(\"Path to copy doesn't exist \" + path);\n  err.code = 'ENOENT';\n  return err;\n};\n\nvar generateDestinationExistsError = function (path) {\n  var err = new Error('Destination path already exists ' + path);\n  err.code = 'EEXIST';\n  return err;\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar checksBeforeCopyingSync = function (from, to, opts) {\n  if (!exists.sync(from)) {\n    throw generateNoSourceError(from);\n  }\n\n  if (exists.sync(to) && !opts.overwrite) {\n    throw generateDestinationExistsError(to);\n  }\n};\n\nvar copyFileSync = function (from, to, mode) {\n  var data = fs.readFileSync(from);\n  write.sync(to, data, { mode: mode });\n};\n\nvar copySymlinkSync = function (from, to) {\n  var symlinkPointsAt = fs.readlinkSync(from);\n  try {\n    fs.symlinkSync(symlinkPointsAt, to);\n  } catch (err) {\n    // There is already file/symlink with this name on destination location.\n    // Must erase it manually, otherwise system won't allow us to place symlink there.\n    if (err.code === 'EEXIST') {\n      fs.unlinkSync(to);\n      // Retry...\n      fs.symlinkSync(symlinkPointsAt, to);\n    } else {\n      throw err;\n    }\n  }\n};\n\nvar copyItemSync = function (from, inspectData, to) {\n  var mode = fileMode.normalizeFileMode(inspectData.mode);\n  if (inspectData.type === 'dir') {\n    dir.createSync(to, { mode: mode });\n  } else if (inspectData.type === 'file') {\n    copyFileSync(from, to, mode);\n  } else if (inspectData.type === 'symlink') {\n    copySymlinkSync(from, to);\n  }\n};\n\nvar copySync = function (from, to, options) {\n  var opts = parseOptions(options, from);\n\n  checksBeforeCopyingSync(from, to, opts);\n\n  treeWalker.sync(from, {\n    inspectOptions: {\n      mode: true,\n      symlinks: true\n    }\n  }, function (path, inspectData) {\n    var rel = pathUtil.relative(from, path);\n    var destPath = pathUtil.resolve(to, rel);\n    if (opts.allowedToCopy(path)) {\n      copyItemSync(path, inspectData, destPath);\n    }\n  });\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar checksBeforeCopyingAsync = function (from, to, opts) {\n  return exists.async(from)\n  .then(function (srcPathExists) {\n    if (!srcPathExists) {\n      throw generateNoSourceError(from);\n    } else {\n      return exists.async(to);\n    }\n  })\n  .then(function (destPathExists) {\n    if (destPathExists && !opts.overwrite) {\n      throw generateDestinationExistsError(to);\n    }\n  });\n};\n\nvar copyFileAsync = function (from, to, mode, retriedAttempt) {\n  return new Promise(function (resolve, reject) {\n    var readStream = fs.createReadStream(from);\n    var writeStream = fs.createWriteStream(to, { mode: mode });\n\n    readStream.on('error', reject);\n\n    writeStream.on('error', function (err) {\n      var toDirPath = pathUtil.dirname(to);\n\n      // Force read stream to close, since write stream errored\n      // read stream serves us no purpose.\n      readStream.resume();\n\n      if (err.code === 'ENOENT' && retriedAttempt === undefined) {\n        // Some parent directory doesn't exits. Create it and retry.\n        dir.createAsync(toDirPath)\n        .then(function () {\n          // Make retry attempt only once to prevent vicious infinite loop\n          // (when for some obscure reason I/O will keep returning ENOENT error).\n          // Passing retriedAttempt = true.\n          copyFileAsync(from, to, mode, true)\n          .then(resolve, reject);\n        })\n        .catch(reject);\n      } else {\n        reject(err);\n      }\n    });\n\n    writeStream.on('finish', resolve);\n\n    readStream.pipe(writeStream);\n  });\n};\n\nvar copySymlinkAsync = function (from, to) {\n  return fs.readlink(from)\n  .then(function (symlinkPointsAt) {\n    return new Promise(function (resolve, reject) {\n      fs.symlink(symlinkPointsAt, to)\n      .then(resolve)\n      .catch(function (err) {\n        if (err.code === 'EEXIST') {\n          // There is already file/symlink with this name on destination location.\n          // Must erase it manually, otherwise system won't allow us to place symlink there.\n          fs.unlink(to)\n          .then(function () {\n            // Retry...\n            return fs.symlink(symlinkPointsAt, to);\n          })\n          .then(resolve, reject);\n        } else {\n          reject(err);\n        }\n      });\n    });\n  });\n};\n\nvar copyItemAsync = function (from, inspectData, to) {\n  var mode = fileMode.normalizeFileMode(inspectData.mode);\n  if (inspectData.type === 'dir') {\n    return dir.createAsync(to, { mode: mode });\n  } else if (inspectData.type === 'file') {\n    return copyFileAsync(from, to, mode);\n  } else if (inspectData.type === 'symlink') {\n    return copySymlinkAsync(from, to);\n  }\n  // Ha! This is none of supported file system entities. What now?\n  // Just continuing without actually copying sounds sane.\n  return Promise.resolve();\n};\n\nvar copyAsync = function (from, to, options) {\n  return new Promise(function (resolve, reject) {\n    var opts = parseOptions(options, from);\n\n    checksBeforeCopyingAsync(from, to, opts)\n    .then(function () {\n      var allFilesDelivered = false;\n      var filesInProgress = 0;\n\n      var stream = treeWalker.stream(from, {\n        inspectOptions: {\n          mode: true,\n          symlinks: true\n        }\n      })\n      .on('readable', function () {\n        var item = stream.read();\n        var rel;\n        var destPath;\n        if (item) {\n          rel = pathUtil.relative(from, item.path);\n          destPath = pathUtil.resolve(to, rel);\n          if (opts.allowedToCopy(item.path)) {\n            filesInProgress += 1;\n            copyItemAsync(item.path, item.item, destPath)\n            .then(function () {\n              filesInProgress -= 1;\n              if (allFilesDelivered && filesInProgress === 0) {\n                resolve();\n              }\n            })\n            .catch(reject);\n          }\n        }\n      })\n      .on('error', reject)\n      .on('end', function () {\n        allFilesDelivered = true;\n        if (allFilesDelivered && filesInProgress === 0) {\n          resolve();\n        }\n      });\n    })\n    .catch(reject);\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = copySync;\nexports.async = copyAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/exists.js":"'use strict';\n\nvar fs = require('./utils/fs');\nvar validate = require('./utils/validate');\n\nvar validateInput = function (methodName, path) {\n  var methodSignature = methodName + '(path)';\n  validate.argument(methodSignature, 'path', path, ['string']);\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar existsSync = function (path) {\n  var stat;\n  try {\n    stat = fs.statSync(path);\n    if (stat.isDirectory()) {\n      return 'dir';\n    } else if (stat.isFile()) {\n      return 'file';\n    }\n    return 'other';\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err;\n    }\n  }\n\n  return false;\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar existsAsync = function (path) {\n  return new Promise(function (resolve, reject) {\n    fs.stat(path, function (err, stat) {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          resolve(false);\n        } else {\n          reject(err);\n        }\n      } else if (stat.isDirectory()) {\n        resolve('dir');\n      } else if (stat.isFile()) {\n        resolve('file');\n      } else {\n        resolve('other');\n      }\n    });\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = existsSync;\nexports.async = existsAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/move.js":"'use strict';\n\nvar pathUtil = require('path');\nvar fs = require('./utils/fs');\nvar validate = require('./utils/validate');\nvar dir = require('./dir');\nvar exists = require('./exists');\n\nvar validateInput = function (methodName, from, to) {\n  var methodSignature = methodName + '(from, to)';\n  validate.argument(methodSignature, 'from', from, ['string']);\n  validate.argument(methodSignature, 'to', to, ['string']);\n};\n\nvar generateSourceDoesntExistError = function (path) {\n  var err = new Error(\"Path to move doesn't exist \" + path);\n  err.code = 'ENOENT';\n  return err;\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar moveSync = function (from, to) {\n  try {\n    fs.renameSync(from, to);\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      // We can't make sense of this error. Rethrow it.\n      throw err;\n    } else {\n      // Ok, source or destination path doesn't exist.\n      // Must do more investigation.\n      if (!exists.sync(from)) {\n        throw generateSourceDoesntExistError(from);\n      }\n      if (!exists.sync(to)) {\n        // Some parent directory doesn't exist. Create it.\n        dir.createSync(pathUtil.dirname(to));\n        // Retry the attempt\n        fs.renameSync(from, to);\n      }\n    }\n  }\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar ensureDestinationPathExistsAsync = function (to) {\n  return new Promise(function (resolve, reject) {\n    var destDir = pathUtil.dirname(to);\n    exists.async(destDir)\n    .then(function (dstExists) {\n      if (!dstExists) {\n        dir.createAsync(destDir)\n        .then(resolve, reject);\n      } else {\n        // Hah, no idea.\n        reject();\n      }\n    })\n    .catch(reject);\n  });\n};\n\nvar moveAsync = function (from, to) {\n  return new Promise(function (resolve, reject) {\n    fs.rename(from, to)\n    .then(resolve)\n    .catch(function (err) {\n      if (err.code !== 'ENOENT') {\n        // Something unknown. Rethrow original error.\n        reject(err);\n      } else {\n        // Ok, source or destination path doesn't exist.\n        // Must do more investigation.\n        exists.async(from)\n        .then(function (srcExists) {\n          if (!srcExists) {\n            reject(generateSourceDoesntExistError(from));\n          } else {\n            ensureDestinationPathExistsAsync(to)\n            .then(function () {\n              // Retry the attempt\n              return fs.rename(from, to);\n            })\n            .then(resolve, reject);\n          }\n        })\n        .catch(reject);\n      }\n    });\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = moveSync;\nexports.async = moveAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/read.js":"/* eslint no-console:1 */\n\n'use strict';\n\nvar fs = require('./utils/fs');\nvar validate = require('./utils/validate');\n\nvar supportedReturnAs = ['utf8', 'buffer', 'json', 'jsonWithDates'];\n\nvar validateInput = function (methodName, path, returnAs) {\n  var methodSignature = methodName + '(path, returnAs)';\n  validate.argument(methodSignature, 'path', path, ['string']);\n  validate.argument(methodSignature, 'returnAs', returnAs, ['string', 'undefined']);\n\n  if (returnAs && supportedReturnAs.indexOf(returnAs) === -1) {\n    throw new Error('Argument \"returnAs\" passed to ' + methodSignature\n      + ' must have one of values: ' + supportedReturnAs.join(', '));\n  }\n};\n\n// Matches strings generated by Date.toJSON()\n// which is called to serialize date to JSON.\nvar jsonDateParser = function (key, value) {\n  var reISO = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*))(?:Z|(\\+|-)([\\d|:]*))?$/;\n  if (typeof value === 'string') {\n    if (reISO.exec(value)) {\n      return new Date(value);\n    }\n  }\n  return value;\n};\n\nvar makeNicerJsonParsingError = function (path, err) {\n  var nicerError = new Error('JSON parsing failed while reading '\n  + path + ' [' + err + ']');\n  nicerError.originalError = err;\n  return nicerError;\n};\n\n// ---------------------------------------------------------\n// SYNC\n// ---------------------------------------------------------\n\nvar readSync = function (path, returnAs) {\n  var retAs = returnAs || 'utf8';\n  var data;\n\n  var encoding = 'utf8';\n  if (retAs === 'buffer') {\n    encoding = null;\n  }\n\n  try {\n    data = fs.readFileSync(path, { encoding: encoding });\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      // If file doesn't exist return undefined instead of throwing.\n      return undefined;\n    }\n    // Otherwise rethrow the error\n    throw err;\n  }\n\n  try {\n    if (retAs === 'json') {\n      data = JSON.parse(data);\n    } else if (retAs === 'jsonWithDates') {\n      data = JSON.parse(data, jsonDateParser);\n    }\n  } catch (err) {\n    throw makeNicerJsonParsingError(path, err);\n  }\n\n  return data;\n};\n\n// ---------------------------------------------------------\n// ASYNC\n// ---------------------------------------------------------\n\nvar readAsync = function (path, returnAs) {\n  return new Promise(function (resolve, reject) {\n    var retAs = returnAs || 'utf8';\n    var encoding = 'utf8';\n    if (retAs === 'buffer') {\n      encoding = null;\n    }\n\n    fs.readFile(path, { encoding: encoding })\n    .then(function (data) {\n      // Make final parsing of the data before returning.\n      try {\n        if (retAs === 'json') {\n          resolve(JSON.parse(data));\n        } else if (retAs === 'jsonWithDates') {\n          resolve(JSON.parse(data, jsonDateParser));\n        } else {\n          resolve(data);\n        }\n      } catch (err) {\n        reject(makeNicerJsonParsingError(path, err));\n      }\n    })\n    .catch(function (err) {\n      if (err.code === 'ENOENT') {\n        // If file doesn't exist return undefined instead of throwing.\n        resolve(undefined);\n      } else {\n        // Otherwise throw\n        reject(err);\n      }\n    });\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = readSync;\nexports.async = readAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/rename.js":"'use strict';\n\nvar pathUtil = require('path');\nvar move = require('./move');\nvar validate = require('./utils/validate');\n\nvar validateInput = function (methodName, path, newName) {\n  var methodSignature = methodName + '(path, newName)';\n  validate.argument(methodSignature, 'path', path, ['string']);\n  validate.argument(methodSignature, 'newName', newName, ['string']);\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar renameSync = function (path, newName) {\n  var newPath = pathUtil.join(pathUtil.dirname(path), newName);\n  move.sync(path, newPath);\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar renameAsync = function (path, newName) {\n  var newPath = pathUtil.join(pathUtil.dirname(path), newName);\n  return move.async(path, newPath);\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = renameSync;\nexports.async = renameAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/symlink.js":"'use strict';\n\nvar pathUtil = require('path');\nvar fs = require('./utils/fs');\nvar validate = require('./utils/validate');\nvar dir = require('./dir');\n\nvar validateInput = function (methodName, symlinkValue, path) {\n  var methodSignature = methodName + '(symlinkValue, path)';\n  validate.argument(methodSignature, 'symlinkValue', symlinkValue, ['string']);\n  validate.argument(methodSignature, 'path', path, ['string']);\n};\n\n// ---------------------------------------------------------\n// Sync\n// ---------------------------------------------------------\n\nvar symlinkSync = function (symlinkValue, path) {\n  try {\n    fs.symlinkSync(symlinkValue, path);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      // Parent directories don't exist. Just create them and rety.\n      dir.createSync(pathUtil.dirname(path));\n      fs.symlinkSync(symlinkValue, path);\n    } else {\n      throw err;\n    }\n  }\n};\n\n// ---------------------------------------------------------\n// Async\n// ---------------------------------------------------------\n\nvar symlinkAsync = function (symlinkValue, path) {\n  return new Promise(function (resolve, reject) {\n    fs.symlink(symlinkValue, path)\n    .then(resolve)\n    .catch(function (err) {\n      if (err.code === 'ENOENT') {\n        // Parent directories don't exist. Just create them and rety.\n        dir.createAsync(pathUtil.dirname(path))\n        .then(function () {\n          return fs.symlink(symlinkValue, path);\n        })\n        .then(resolve, reject);\n      } else {\n        reject(err);\n      }\n    });\n  });\n};\n\n// ---------------------------------------------------------\n// API\n// ---------------------------------------------------------\n\nexports.validateInput = validateInput;\nexports.sync = symlinkSync;\nexports.async = symlinkAsync;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/lib/streams.js":"'use strict';\n\nvar fs = require('fs');\n\nexports.createWriteStream = fs.createWriteStream;\nexports.createReadStream = fs.createReadStream;\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/benchmark/copy.js":"/* eslint no-console: 0 */\n\n'use strict';\n\nvar utils = require('./utils');\n\nvar testDir = utils.prepareJetpackTestDir();\nvar toCopyDir = testDir.dir('to-copy');\nvar timer;\nvar jetpackTime;\nvar nativeTime;\n\nvar test = function (testConfig) {\n  console.log('');\n\n  return utils.prepareFiles(toCopyDir, testConfig)\n  .then(utils.waitAWhile)\n  .then(function () {\n    timer = utils.startTimer('jetpack.copyAsync()');\n    return toCopyDir.copyAsync('.', testDir.path('copied-jetpack'));\n  })\n  .then(function () {\n    jetpackTime = timer();\n    return utils.waitAWhile();\n  })\n  .then(function () {\n    timer = utils.startTimer('Native cp -R');\n    return utils.exec('cp -R ' + toCopyDir.path() + ' ' + testDir.path('copied-native'));\n  })\n  .then(function () {\n    nativeTime = timer();\n    utils.showDifferenceInfo(jetpackTime, nativeTime);\n    return utils.cleanAfterTest();\n  })\n  .catch(function (err) {\n    console.log(err);\n  });\n};\n\nvar testConfigs = [\n  {\n    files: 10000,\n    size: 1000\n  },\n  {\n    files: 50,\n    size: 1000 * 1000 * 10\n  }\n];\n\nvar runNext = function () {\n  if (testConfigs.length > 0) {\n    test(testConfigs.pop()).then(runNext);\n  }\n};\n\nrunNext();\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/benchmark/utils.js":"/* eslint no-console:0 */\n\n'use strct';\n\nvar os = require('os');\nvar childProcess = require('child_process');\nvar promisify = require('../lib/utils/promisify');\nvar jetpack = require('..');\n\nvar humanReadableFileSize = function (bytes, si) {\n  var units;\n  var u;\n  var b = bytes;\n  var thresh = si ? 1000 : 1024;\n  if (Math.abs(b) < thresh) {\n    return b + ' B';\n  }\n  units = si\n    ? ['kB', 'MB', 'GB', 'TB']\n    : ['KiB', 'MiB', 'GiB', 'TiB'];\n  u = -1;\n  do {\n    b /= thresh;\n    ++u;\n  } while (Math.abs(b) >= thresh && u < units.length - 1);\n  return b.toFixed(1) + ' ' + units[u];\n};\n\nvar testDirPath = function () {\n  return os.tmpdir() + '/jetpack-benchmark';\n};\n\nvar prepareJetpackTestDir = function () {\n  return jetpack.dir(testDirPath(), { empty: true });\n};\n\nvar prepareFiles = function (jetpackDir, creationConfig) {\n  return new Promise(function (resolve, reject) {\n    var count = 0;\n    var content = new Buffer(creationConfig.size);\n\n    var makeOneFile = function () {\n      jetpackDir.fileAsync(count + '.txt', { content: content })\n      .then(function () {\n        count += 1;\n        if (count < creationConfig.files) {\n          makeOneFile();\n        } else {\n          resolve();\n        }\n      }, reject);\n    };\n\n    console.log('Preparing ' + creationConfig.files + ' test files (' +\n        humanReadableFileSize(creationConfig.size, true) + ' each)...');\n    makeOneFile();\n  });\n};\n\nvar startTimer = function (startMessage) {\n  var start = Date.now();\n  process.stdout.write(startMessage + ' ... ');\n  return function stop() {\n    var time = Date.now() - start;\n    console.log(time + 'ms');\n    return time;\n  };\n};\n\nvar waitAWhile = function () {\n  return new Promise(function (resolve) {\n    console.log('Waiting 5s to allow hardware buffers be emptied...');\n    setTimeout(resolve, 5000);\n  });\n};\n\nvar promisedExec = promisify(childProcess.exec);\n\nvar showDifferenceInfo = function (jetpackTime, nativeTime) {\n  var perc = Math.round(jetpackTime / nativeTime * 100) - 100;\n  console.log('Jetpack is ' + perc + '% slower than native');\n};\n\nvar cleanAfterTest = function () {\n  console.log('Cleaning up after test...');\n  return jetpack.removeAsync(testDirPath());\n};\n\nmodule.exports = {\n  prepareJetpackTestDir: prepareJetpackTestDir,\n  prepareFiles: prepareFiles,\n  startTimer: startTimer,\n  waitAWhile: waitAWhile,\n  exec: promisedExec,\n  showDifferenceInfo: showDifferenceInfo,\n  cleanAfterTest: cleanAfterTest\n};\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/benchmark/remove.js":"/* eslint no-console: 0 */\n\n'use strict';\n\nvar utils = require('./utils');\n\nvar testDir = utils.prepareJetpackTestDir();\nvar timer;\nvar jetpackTime;\nvar nativeTime;\n\nvar test = function (testConfig) {\n  var dirJet = testDir.dir('to-be-removed-by-jetpack');\n  var dirNative = testDir.dir('to-be-removed-by-native');\n\n  console.log('');\n\n  return utils.prepareFiles(dirJet, testConfig)\n  .then(function () {\n    return utils.prepareFiles(dirNative, testConfig);\n  })\n  .then(utils.waitAWhile)\n  .then(function () {\n    timer = utils.startTimer('jetpack.removeAsync()');\n    return dirJet.removeAsync();\n  })\n  .then(function () {\n    jetpackTime = timer();\n    return utils.waitAWhile();\n  })\n  .then(function () {\n    timer = utils.startTimer('Native rm -rf');\n    return utils.exec('rm -rf ' + dirNative.path());\n  })\n  .then(function () {\n    nativeTime = timer();\n    utils.showDifferenceInfo(jetpackTime, nativeTime);\n    return utils.cleanAfterTest();\n  })\n  .catch(function (err) {\n    console.log(err);\n  });\n};\n\nvar testConfigs = [\n  {\n    files: 10000,\n    size: 1000\n  }\n];\n\nvar runNext = function () {\n  if (testConfigs.length > 0) {\n    test(testConfigs.pop()).then(runNext);\n  }\n};\n\nrunNext();\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/append.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('append', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('appends String to file', function () {\n    var preparations = function () {\n      fse.writeFileSync('file.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent('abcxyz');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.append('file.txt', 'xyz');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.appendAsync('file.txt', 'xyz')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('appends Buffer to file', function () {\n    var preparations = function () {\n      fse.writeFileSync('file.bin', new Buffer([11]));\n    };\n\n    var expectations = function () {\n      path('file.bin').shouldBeFileWithContent(new Buffer([11, 22]));\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.append('file.bin', new Buffer([22]));\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.appendAsync('file.bin', new Buffer([22]))\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe(\"if file doesn't exist creates it\", function () {\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent('xyz');\n    };\n\n    it('sync', function () {\n      jetpack.append('file.txt', 'xyz');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.appendAsync('file.txt', 'xyz')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe(\"if parent directory doesn't exist creates it\", function () {\n    var expectations = function () {\n      path('dir/dir/file.txt').shouldBeFileWithContent('xyz');\n    };\n\n    it('sync', function () {\n      jetpack.append('dir/dir/file.txt', 'xyz');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.appendAsync('dir/dir/file.txt', 'xyz')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a/b.txt').shouldBeFileWithContent('abcxyz');\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.append('b.txt', 'xyz');\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.appendAsync('b.txt', 'xyz')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.append, methodName: 'append' },\n      { type: 'async', method: jetpack.appendAsync, methodName: 'appendAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined, 'xyz');\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path, data, [options]) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"data\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method('abc');\n          }).to.throw('Argument \"data\" passed to ' + test.methodName\n            + '(path, data, [options]) must be a string or a buffer. Received undefined');\n        });\n      });\n    });\n\n    describe('\"options\" object', function () {\n      describe('\"mode\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', 'xyz', { mode: true });\n            }).to.throw('Argument \"options.mode\" passed to ' + test.methodName\n              + '(path, data, [options]) must be a string or a number. Received boolean');\n          });\n        });\n      });\n    });\n  });\n\n  if (process.platform !== 'win32') {\n    describe('sets file mode on created file (unix only)', function () {\n      var expectations = function () {\n        path('file.txt').shouldHaveMode('711');\n      };\n\n      it('sync', function () {\n        jetpack.append('file.txt', 'abc', { mode: '711' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        jetpack.appendAsync('file.txt', 'abc', { mode: '711' })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/assert_path.js":"var fs = require('fs');\n\nvar areBuffersEqual = function (bufA, bufB) {\n  var i;\n  var len = bufA.length;\n  if (len !== bufB.length) {\n    return false;\n  }\n  for (i = 0; i < len; i++) {\n    if (bufA.readUInt8(i) !== bufB.readUInt8(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = function (path) {\n  return {\n    shouldNotExist: function () {\n      var message;\n      try {\n        fs.statSync(path);\n        message = 'Path ' + path + ' should NOT exist';\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      }\n      if (message) {\n        throw new Error(message);\n      }\n    },\n\n    shouldBeDirectory: function () {\n      var message;\n      var stat;\n      try {\n        stat = fs.statSync(path);\n        if (!stat.isDirectory()) {\n          message = 'Path ' + path + ' should be a directory';\n        }\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          message = 'Path ' + path + ' should exist';\n        } else {\n          throw err;\n        }\n      }\n      if (message) {\n        throw new Error(message);\n      }\n    },\n\n    shouldBeFileWithContent: function (expectedContent) {\n      var message;\n      var content;\n\n      var generateMessage = function (expected, found) {\n        message = 'File ' + path + ' should have content \"'\n          + expected + '\" but have instead \"' + found + '\"';\n      };\n\n      try {\n        if (Buffer.isBuffer(expectedContent)) {\n          content = fs.readFileSync(path);\n          if (!areBuffersEqual(expectedContent, content)) {\n            generateMessage(expectedContent.toString('hex'), content.toString('hex'));\n          }\n        } else {\n          content = fs.readFileSync(path, 'utf8');\n          if (content !== expectedContent) {\n            generateMessage(expectedContent, content);\n          }\n        }\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          message = 'File ' + path + ' should exist';\n        } else {\n          throw err;\n        }\n      }\n      if (message) {\n        throw new Error(message);\n      }\n    },\n\n    shouldHaveMode: function (expectedMode) {\n      var mode;\n      var message;\n      try {\n        mode = fs.statSync(path).mode.toString(8);\n        mode = mode.substring(mode.length - 3);\n        if (mode !== expectedMode) {\n          message = 'Path ' + path + ' should have mode \"'\n            + expectedMode + '\" but have instead \"' + mode + '\"';\n        }\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          message = 'Path ' + path + ' should exist';\n        } else {\n          throw err;\n        }\n      }\n      if (message) {\n        throw new Error(message);\n      }\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/copy.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('copy', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('copies a file', function () {\n    var preparations = function () {\n      fse.outputFileSync('file.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent('abc');\n      path('file_copied.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.copy('file.txt', 'file_copied.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.copyAsync('file.txt', 'file_copied.txt')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('can copy file to nonexistent directory (will create directory)', function () {\n    var preparations = function () {\n      fse.outputFileSync('file.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent('abc');\n      path('dir/dir/file.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.copy('file.txt', 'dir/dir/file.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.copyAsync('file.txt', 'dir/dir/file.txt')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('copies empty directory', function () {\n    var preparations = function () {\n      fse.mkdirsSync('dir');\n    };\n\n    var expectations = function () {\n      path('copied/dir').shouldBeDirectory();\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.copy('dir', 'copied/dir');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.copyAsync('dir', 'copied/dir')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('copies a tree of files', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/f1.txt', 'abc');\n      fse.outputFileSync('a/b/f2.txt', '123');\n      fse.mkdirsSync('a/b/c');\n    };\n\n    var expectations = function () {\n      path('copied/a/f1.txt').shouldBeFileWithContent('abc');\n      path('copied/a/b/c').shouldBeDirectory();\n      path('copied/a/b/f2.txt').shouldBeFileWithContent('123');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.copy('a', 'copied/a');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.copyAsync('a', 'copied/a')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe(\"generates nice error if source path doesn't exist\", function () {\n    var expectations = function (err) {\n      expect(err.code).to.equal('ENOENT');\n      expect(err.message).to.have.string(\"Path to copy doesn't exist\");\n    };\n\n    it('sync', function () {\n      try {\n        jetpack.copy('a', 'b');\n        throw new Error('Expected error to be thrown');\n      } catch (err) {\n        expectations(err);\n      }\n    });\n\n    it('async', function (done) {\n      jetpack.copyAsync('a', 'b')\n      .catch(function (err) {\n        expectations(err);\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a/b.txt').shouldBeFileWithContent('abc');\n      path('a/x.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.copy('b.txt', 'x.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.copyAsync('b.txt', 'x.txt')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('overwriting behaviour', function () {\n    describe('does not overwrite by default', function () {\n      var preparations = function () {\n        fse.outputFileSync('a/file.txt', 'abc');\n        fse.mkdirsSync('b');\n      };\n\n      var expectations = function (err) {\n        expect(err.code).to.equal('EEXIST');\n        expect(err.message).to.have.string('Destination path already exists');\n      };\n\n      it('sync', function () {\n        preparations();\n        try {\n          jetpack.copy('a', 'b');\n          throw new Error('Expected error to be thrown');\n        } catch (err) {\n          expectations(err);\n        }\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.copyAsync('a', 'b')\n        .catch(function (err) {\n          expectations(err);\n          done();\n        });\n      });\n    });\n\n    describe('overwrites if it was specified', function () {\n      var preparations = function () {\n        fse.outputFileSync('a/file.txt', 'abc');\n        fse.outputFileSync('b/file.txt', 'xyz');\n      };\n\n      var expectations = function () {\n        path('a/file.txt').shouldBeFileWithContent('abc');\n        path('b/file.txt').shouldBeFileWithContent('abc');\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.copy('a', 'b', { overwrite: true });\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.copyAsync('a', 'b', { overwrite: true })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n  });\n\n  describe('filter what to copy', function () {\n    describe('by simple pattern', function () {\n      var preparations = function () {\n        fse.outputFileSync('dir/file.txt', '1');\n        fse.outputFileSync('dir/file.md', 'm1');\n        fse.outputFileSync('dir/a/file.txt', '2');\n        fse.outputFileSync('dir/a/file.md', 'm2');\n      };\n\n      var expectations = function () {\n        path('copy/file.txt').shouldBeFileWithContent('1');\n        path('copy/file.md').shouldNotExist();\n        path('copy/a/file.txt').shouldBeFileWithContent('2');\n        path('copy/a/file.md').shouldNotExist();\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.copy('dir', 'copy', { matching: '*.txt' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.copyAsync('dir', 'copy', { matching: '*.txt' })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n\n    describe('by pattern anchored to copied directory', function () {\n      var preparations = function () {\n        fse.outputFileSync('x/y/dir/file.txt', '1');\n        fse.outputFileSync('x/y/dir/a/file.txt', '2');\n        fse.outputFileSync('x/y/dir/a/b/file.txt', '3');\n      };\n\n      var expectations = function () {\n        path('copy/file.txt').shouldNotExist();\n        path('copy/a/file.txt').shouldBeFileWithContent('2');\n        path('copy/a/b/file.txt').shouldNotExist();\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.copy('x/y/dir', 'copy', { matching: 'a/*.txt' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.copyAsync('x/y/dir', 'copy', { matching: 'a/*.txt' })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n\n    describe('can use ./ as indication of anchor directory', function () {\n      var preparations = function () {\n        fse.outputFileSync('x/y/a.txt', '123');\n        fse.outputFileSync('x/y/b/a.txt', '456');\n      };\n\n      var expectations = function () {\n        path('copy/a.txt').shouldBeFileWithContent('123');\n        path('copy/b/a.txt').shouldNotExist();\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.copy('x/y', 'copy', { matching: './a.txt' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.copyAsync('x/y', 'copy', { matching: './a.txt' })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n\n    describe('matching works also if copying single file', function () {\n      var preparations = function () {\n        fse.outputFileSync('a', '123');\n        fse.outputFileSync('x', '456');\n      };\n\n      var expectations = function () {\n        path('a-copy').shouldNotExist();\n        path('x-copy').shouldBeFileWithContent('456');\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.copy('a', 'a-copy', { matching: 'x' });\n        jetpack.copy('x', 'x-copy', { matching: 'x' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.copyAsync('a', 'a-copy', { matching: 'x' })\n        .then(function () {\n          return jetpack.copyAsync('x', 'x-copy', { matching: 'x' });\n        })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n\n    describe('can use negation in patterns', function () {\n      var preparations = function () {\n        fse.mkdirsSync('x/y/dir/a/b');\n        fse.mkdirsSync('x/y/dir/a/x');\n        fse.mkdirsSync('x/y/dir/a/y');\n        fse.mkdirsSync('x/y/dir/a/z');\n      };\n\n      var expectations = function () {\n        path('copy/dir/a/b').shouldBeDirectory();\n        path('copy/dir/a/x').shouldNotExist();\n        path('copy/dir/a/y').shouldNotExist();\n        path('copy/dir/a/z').shouldNotExist();\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.copy('x/y', 'copy', {\n          matching: [\n            '**',\n            // Three different pattern types to test:\n            '!x',\n            '!dir/a/y',\n            '!./dir/a/z'\n          ]\n        });\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.copyAsync('x/y', 'copy', {\n          matching: [\n            '**',\n            // Three different pattern types to test:\n            '!x',\n            '!dir/a/y',\n            '!./dir/a/z'\n          ]\n        })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n\n    describe('wildcard copies everything', function () {\n      var preparations = function () {\n        // Just a file\n        fse.outputFileSync('x/file.txt', '123');\n        // Dot file\n        fse.outputFileSync('x/y/.dot', 'dot');\n        // Empty directory\n        fse.mkdirsSync('x/y/z');\n      };\n\n      var expectations = function () {\n        path('copy/file.txt').shouldBeFileWithContent('123');\n        path('copy/y/.dot').shouldBeFileWithContent('dot');\n        path('copy/y/z').shouldBeDirectory();\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.copy('x', 'copy', { matching: '**' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.copyAsync('x', 'copy', { matching: '**' })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n  });\n\n  describe('can copy symlink', function () {\n    var preparations = function () {\n      fse.mkdirsSync('to_copy');\n      fse.symlinkSync('some/file', 'to_copy/symlink');\n    };\n    var expectations = function () {\n      expect(fse.lstatSync('copied/symlink').isSymbolicLink()).to.equal(true);\n      expect(fse.readlinkSync('copied/symlink')).to.equal(helper.osSep('some/file'));\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.copy('to_copy', 'copied');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.copyAsync('to_copy', 'copied')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('can overwrite symlink', function () {\n    var preparations = function () {\n      fse.mkdirsSync('to_copy');\n      fse.symlinkSync('some/file', 'to_copy/symlink');\n      fse.mkdirsSync('copied');\n      fse.symlinkSync('some/other_file', 'copied/symlink');\n    };\n\n    var expectations = function () {\n      expect(fse.lstatSync('copied/symlink').isSymbolicLink()).to.equal(true);\n      expect(fse.readlinkSync('copied/symlink')).to.equal(helper.osSep('some/file'));\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.copy('to_copy', 'copied', { overwrite: true });\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.copyAsync('to_copy', 'copied', { overwrite: true })\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  if (process.platform !== 'win32') {\n    describe('copies also file permissions (unix only)', function () {\n      var preparations = function () {\n        fse.outputFileSync('a/b/c.txt', 'abc');\n        fse.chmodSync('a/b', '700');\n        fse.chmodSync('a/b/c.txt', '711');\n      };\n\n      var expectations = function () {\n        path('x/b').shouldHaveMode('700');\n        path('x/b/c.txt').shouldHaveMode('711');\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.copy('a', 'x');\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.copyAsync('a', 'x')\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n  }\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.copy, methodName: 'copy' },\n      { type: 'async', method: jetpack.copyAsync, methodName: 'copyAsync' }\n    ];\n\n    describe('\"from\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined, 'xyz');\n          }).to.throw('Argument \"from\" passed to ' + test.methodName\n            + '(from, to, [options]) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"to\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method('abc');\n          }).to.throw('Argument \"to\" passed to ' + test.methodName\n            + '(from, to, [options]) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"options\" object', function () {\n      describe('\"overwrite\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', 'xyz', { overwrite: 1 });\n            }).to.throw('Argument \"options.overwrite\" passed to ' + test.methodName\n              + '(from, to, [options]) must be a boolean. Received number');\n          });\n        });\n      });\n      describe('\"matching\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', 'xyz', { matching: 1 });\n            }).to.throw('Argument \"options.matching\" passed to ' + test.methodName\n              + '(from, to, [options]) must be a string or an array of string. Received number');\n          });\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/cwd.spec.js":"var pathUtil = require('path');\nvar expect = require('chai').expect;\nvar jetpack = require('..');\n\ndescribe('cwd', function () {\n  it('returns the same path as process.cwd for main instance of jetpack', function () {\n    expect(jetpack.cwd()).to.equal(process.cwd());\n  });\n\n  it('can create new context with different cwd', function () {\n    var jetCwd = jetpack.cwd('/'); // absolute path\n    expect(jetCwd.cwd()).to.equal(pathUtil.resolve(process.cwd(), '/'));\n\n    jetCwd = jetpack.cwd('../..'); // relative path\n    expect(jetCwd.cwd()).to.equal(pathUtil.resolve(process.cwd(), '../..'));\n\n    expect(jetpack.cwd()).to.equal(process.cwd()); // cwd of main lib should be intact\n  });\n\n  it('cwd contexts can be created recursively', function () {\n    var jetCwd1;\n    var jetCwd2;\n\n    jetCwd1 = jetpack.cwd('..');\n    expect(jetCwd1.cwd()).to.equal(pathUtil.resolve(process.cwd(), '..'));\n\n    jetCwd2 = jetCwd1.cwd('..');\n    expect(jetCwd2.cwd()).to.equal(pathUtil.resolve(process.cwd(), '../..'));\n  });\n\n  it('cwd can join path parts', function () {\n    var jetCwd = jetpack.cwd('a', 'b', 'c');\n    expect(jetCwd.cwd()).to.equal(pathUtil.resolve(process.cwd(), 'a', 'b', 'c'));\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/dir.spec.js":"var fse = require('fs-extra');\nvar pathUtil = require('path');\nvar expect = require('chai').expect;\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('dir', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe(\"creates directory if it doesn't exist\", function () {\n    var expectations = function () {\n      path('x').shouldBeDirectory();\n    };\n\n    it('sync', function () {\n      jetpack.dir('x');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.dirAsync('x')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('does nothing if directory already exists', function () {\n    var preparations = function () {\n      fse.mkdirsSync('x');\n    };\n\n    var expectations = function () {\n      path('x').shouldBeDirectory();\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.dir('x');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.dirAsync('x')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('creates nested directories if necessary', function () {\n    var expectations = function () {\n      path('a/b/c').shouldBeDirectory();\n    };\n\n    it('sync', function () {\n      jetpack.dir('a/b/c');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.dirAsync('a/b/c')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('handles well two calls racing to create the same directory', function () {\n    var expectations = function () {\n      path('a/b/c').shouldBeDirectory();\n    };\n\n    it('async', function (done) {\n      var doneCount = 0;\n      var check = function () {\n        doneCount += 1;\n        if (doneCount === 2) {\n          expectations();\n          done();\n        }\n      };\n      jetpack.dirAsync('a/b/c').then(check);\n      jetpack.dirAsync('a/b/c').then(check);\n    });\n  });\n\n  describe(\"doesn't touch directory content by default\", function () {\n    var preparations = function () {\n      fse.mkdirsSync('a/b');\n      fse.outputFileSync('a/c.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a/b').shouldBeDirectory();\n      path('a/c.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.dir('a');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.dirAsync('a')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('makes directory empty if that option specified', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/file.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a/b/file.txt').shouldNotExist();\n      path('a').shouldBeDirectory();\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.dir('a', { empty: true });\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.dirAsync('a', { empty: true })\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('throws if given path is something other than directory', function () {\n    var preparations = function () {\n      fse.outputFileSync('a', 'abc');\n    };\n\n    var expectations = function (err) {\n      expect(err.message).to.have.string('exists but is not a directory');\n    };\n\n    it('sync', function () {\n      preparations();\n      try {\n        jetpack.dir('a');\n        throw new Error('Expected error to be thrown');\n      } catch (err) {\n        expectations(err);\n      }\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.dirAsync('a')\n      .catch(function (err) {\n        expectations(err);\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var expectations = function () {\n      path('a/b').shouldBeDirectory();\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      jetContext.dir('b');\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      jetContext.dirAsync('b')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('returns jetack instance pointing on this directory', function () {\n    var expectations = function (jetpackContext) {\n      expect(jetpackContext.cwd()).to.equal(pathUtil.resolve('a'));\n    };\n\n    it('sync', function () {\n      expectations(jetpack.dir('a'));\n    });\n\n    it('async', function (done) {\n      jetpack.dirAsync('a')\n      .then(function (jetpackContext) {\n        expectations(jetpackContext);\n        done();\n      });\n    });\n  });\n\n\n  if (process.platform !== 'win32') {\n    describe('sets mode to newly created directory (unix only)', function () {\n      var expectations = function () {\n        path('a').shouldHaveMode('511');\n      };\n\n      it('sync, mode passed as string', function () {\n        jetpack.dir('a', { mode: '511' });\n        expectations();\n      });\n\n      it('sync, mode passed as number', function () {\n        jetpack.dir('a', { mode: parseInt('511', 8) });\n        expectations();\n      });\n\n      it('async, mode passed as string', function (done) {\n        jetpack.dirAsync('a', { mode: '511' })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n\n      it('async, mode passed as number', function (done) {\n        jetpack.dirAsync('a', { mode: parseInt('511', 8) })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n\n    describe('sets desired mode to every created directory (unix only)', function () {\n      var expectations = function () {\n        path('a').shouldHaveMode('711');\n        path('a/b').shouldHaveMode('711');\n      };\n\n      it('sync', function () {\n        jetpack.dir('a/b', { mode: '711' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        jetpack.dirAsync('a/b', { mode: '711' })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n\n    describe('changes mode of existing directory to desired (unix only)', function () {\n      var preparations = function () {\n        fse.mkdirSync('a', '777');\n      };\n      var expectations = function () {\n        path('a').shouldHaveMode('511');\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.dir('a', { mode: '511' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.dirAsync('a', { mode: '511' })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n\n    describe('leaves mode of directory intact by default (unix only)', function () {\n      var preparations = function () {\n        fse.mkdirSync('a', '700');\n      };\n\n      var expectations = function () {\n        path('a').shouldHaveMode('700');\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.dir('a');\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.dirAsync('a')\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n  } else {\n    describe('specyfying mode have no effect and throws no error (windows only)', function () {\n      var expectations = function () {\n        path('x').shouldBeDirectory();\n      };\n\n      it('sync', function () {\n        jetpack.dir('x', { mode: '511' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        jetpack.dirAsync('x', { mode: '511' })\n        .then(function () {\n          expectations();\n          done();\n        });\n      });\n    });\n  }\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.dir, methodName: 'dir' },\n      { type: 'async', method: jetpack.dirAsync, methodName: 'dirAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined);\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path, [criteria]) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"criteria\" object', function () {\n      describe('\"empty\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { empty: 1 });\n            }).to.throw('Argument \"criteria.empty\" passed to ' + test.methodName\n              + '(path, [criteria]) must be a boolean. Received number');\n          });\n        });\n      });\n      describe('\"mode\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { mode: true });\n            }).to.throw('Argument \"criteria.mode\" passed to ' + test.methodName\n              + '(path, [criteria]) must be a string or a number. Received boolean');\n          });\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/exists.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('exists', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe(\"returns false if file doesn't exist\", function () {\n    var expectations = function (exists) {\n      expect(exists).to.equal(false);\n    };\n\n    it('sync', function () {\n      expectations(jetpack.exists('file.txt'));\n    });\n\n    it('async', function (done) {\n      jetpack.existsAsync('file.txt')\n      .then(function (exists) {\n        expectations(exists);\n        done();\n      });\n    });\n  });\n\n  describe(\"returns 'dir' if directory exists on given path\", function () {\n    var preparations = function () {\n      fse.mkdirsSync('a');\n    };\n\n    var expectations = function (exists) {\n      expect(exists).to.equal('dir');\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.exists('a'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.existsAsync('a')\n      .then(function (exists) {\n        expectations(exists);\n        done();\n      });\n    });\n  });\n\n  describe(\"returns 'file' if file exists on given path\", function () {\n    var preparations = function () {\n      fse.outputFileSync('text.txt', 'abc');\n    };\n\n    var expectations = function (exists) {\n      expect(exists).to.equal('file');\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.exists('text.txt'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.existsAsync('text.txt')\n      .then(function (exists) {\n        expectations(exists);\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/text.txt', 'abc');\n    };\n\n    var expectations = function (exists) {\n      expect(exists).to.equal('file');\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      expectations(jetContext.exists('text.txt'));\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.existsAsync('text.txt')\n      .then(function (exists) {\n        expectations(exists);\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.exists, methodName: 'exists' },\n      { type: 'async', method: jetpack.existsAsync, methodName: 'existsAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined);\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path) must be a string. Received undefined');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/file.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('file', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe(\"creates file if it doesn't exist\", function () {\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent('');\n    };\n\n    it('sync', function () {\n      jetpack.file('file.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.fileAsync('file.txt')\n      .then(function () {\n        expectations();\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('leaves file intact if it already exists', function () {\n    var preparations = function () {\n      fse.outputFileSync('file.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.file('file.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.fileAsync('file.txt')\n      .then(function () {\n        expectations();\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('can save file content given as string', function () {\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent('ąbć');\n    };\n\n    it('sync', function () {\n      jetpack.file('file.txt', { content: 'ąbć' });\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.fileAsync('file.txt', { content: 'ąbć' })\n      .then(function () {\n        expectations();\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('can save file content given as buffer', function () {\n    var expectations = function () {\n      path('file').shouldBeFileWithContent(new Buffer([11, 22]));\n    };\n\n    it('sync', function () {\n      jetpack.file('file', { content: new Buffer([11, 22]) });\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.fileAsync('file', { content: new Buffer([11, 22]) })\n      .then(function () {\n        expectations();\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('can save file content given as plain JS object (will be saved as JSON)', function () {\n    var obj = {\n      a: 'abc',\n      b: 123\n    };\n\n    var expectations = function () {\n      var data = JSON.parse(fse.readFileSync('file.txt', 'utf8'));\n      expect(data).to.eql(obj);\n    };\n\n    it('sync', function () {\n      jetpack.file('file.txt', { content: obj });\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.fileAsync('file.txt', { content: obj })\n      .then(function () {\n        expectations();\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('written JSON data can be indented', function () {\n    var obj = {\n      a: 'abc',\n      b: 123\n    };\n\n    var expectations = function () {\n      var sizeA = fse.statSync('a.json').size;\n      var sizeB = fse.statSync('b.json').size;\n      var sizeC = fse.statSync('c.json').size;\n      expect(sizeB).to.be.above(sizeA);\n      expect(sizeC).to.be.above(sizeB);\n    };\n\n    it('sync', function () {\n      jetpack.file('a.json', { content: obj, jsonIndent: 0 });\n      jetpack.file('b.json', { content: obj }); // Default indent = 2\n      jetpack.file('c.json', { content: obj, jsonIndent: 4 });\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.fileAsync('a.json', { content: obj, jsonIndent: 0 })\n      .then(function () {\n        return jetpack.fileAsync('b.json', { content: obj }); // Default indent = 2\n      })\n      .then(function () {\n        return jetpack.fileAsync('c.json', { content: obj, jsonIndent: 4 });\n      })\n      .then(function () {\n        expectations();\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('replaces content of already existing file', function () {\n    var preparations = function () {\n      fse.writeFileSync('file.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent('123');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.file('file.txt', { content: '123' });\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.fileAsync('file.txt', { content: '123' })\n      .then(function () {\n        expectations();\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('throws if given path is not a file', function () {\n    var preparations = function () {\n      fse.mkdirsSync('a');\n    };\n\n    var expectations = function (err) {\n      expect(err.message).to.have.string('exists but is not a file.');\n    };\n\n    it('sync', function () {\n      preparations();\n      try {\n        jetpack.file('a');\n        throw new Error('Expected error to be thrown');\n      } catch (err) {\n        expectations(err);\n      }\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.fileAsync('a')\n      .catch(function (err) {\n        expectations(err);\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe(\"if directory for file doesn't exist creates it as well\", function () {\n    var expectations = function () {\n      path('a/b/c.txt').shouldBeFileWithContent('');\n    };\n\n    it('sync', function () {\n      jetpack.file('a/b/c.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.fileAsync('a/b/c.txt')\n      .then(function () {\n        expectations();\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('returns currently used jetpack instance', function () {\n    var expectations = function (jetpackContext) {\n      expect(jetpackContext).to.equal(jetpack);\n    };\n\n    it('sync', function () {\n      expectations(jetpack.file('file.txt'));\n    });\n\n    it('async', function (done) {\n      jetpack.fileAsync('file.txt')\n      .then(function (jetpackContext) {\n        expectations(jetpackContext);\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var expectations = function () {\n      path('a/b.txt').shouldBeFileWithContent('');\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      jetContext.file('b.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      jetContext.fileAsync('b.txt')\n      .then(function () {\n        expectations();\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  if (process.platform !== 'win32') {\n    describe('sets mode of newly created file (unix only)', function () {\n      var expectations = function () {\n        path('file.txt').shouldHaveMode('711');\n      };\n\n      it('sync, mode passed as string', function () {\n        jetpack.file('file.txt', { mode: '711' });\n        expectations();\n      });\n\n      it('sync, mode passed as number', function () {\n        jetpack.file('file.txt', { mode: parseInt('711', 8) });\n        expectations();\n      });\n\n      it('async, mode passed as string', function (done) {\n        jetpack.fileAsync('file.txt', { mode: '711' })\n        .then(function () {\n          expectations();\n          done();\n        })\n        .catch(done);\n      });\n\n      it('async, mode passed as number', function (done) {\n        jetpack.fileAsync('file.txt', { mode: parseInt('711', 8) })\n        .then(function () {\n          expectations();\n          done();\n        })\n        .catch(done);\n      });\n    });\n\n    describe(\"changes mode of existing file if it doesn't match (unix only)\", function () {\n      var preparations = function () {\n        fse.writeFileSync('file.txt', 'abc', { mode: '700' });\n      };\n\n      var expectations = function () {\n        path('file.txt').shouldHaveMode('511');\n      };\n\n      it('sync', function () {\n        preparations();\n        jetpack.file('file.txt', { mode: '511' });\n        expectations();\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.fileAsync('file.txt', { mode: '511' })\n        .then(function () {\n          expectations();\n          done();\n        })\n        .catch(done);\n      });\n    });\n\n    describe('leaves mode of file intact if not explicitly specified (unix only)', function () {\n      var preparations = function () {\n        fse.writeFileSync('file.txt', 'abc', { mode: '700' });\n      };\n\n      var expectations = function () {\n        path('file.txt').shouldHaveMode('700');\n      };\n\n      it('sync, ensure exists', function () {\n        preparations();\n        jetpack.file('file.txt');\n        expectations();\n      });\n\n      it('sync, ensure content', function () {\n        preparations();\n        jetpack.file('file.txt', { content: 'abc' });\n        expectations();\n      });\n\n      it('async, ensure exists', function (done) {\n        preparations();\n        jetpack.fileAsync('file.txt')\n        .then(function () {\n          expectations();\n          done();\n        })\n        .catch(done);\n      });\n\n      it('async, ensure content', function (done) {\n        preparations();\n        jetpack.fileAsync('file.txt', { content: 'abc' })\n        .then(function () {\n          expectations();\n          done();\n        })\n        .catch(done);\n      });\n    });\n  } else {\n    describe('specyfying mode have no effect and throws no error (windows only)', function () {\n      it('sync', function () {\n        jetpack.file('file.txt', { mode: '711' });\n      });\n\n      it('async', function (done) {\n        jetpack.fileAsync('file.txt', { mode: '711' })\n        .then(function () {\n          done();\n        })\n        .catch(done);\n      });\n    });\n  }\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.file, methodName: 'file' },\n      { type: 'async', method: jetpack.fileAsync, methodName: 'fileAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined);\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path, [criteria]) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"criteria\" object', function () {\n      describe('\"content\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { content: 1 });\n            }).to.throw('Argument \"criteria.content\" passed to ' + test.methodName\n              + '(path, [criteria]) must be a string or a buffer or an object or '\n              + 'an array. Received number');\n          });\n        });\n      });\n      describe('\"jsonIndent\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { jsonIndent: true });\n            }).to.throw('Argument \"criteria.jsonIndent\" passed to ' + test.methodName\n              + '(path, [criteria]) must be a number. Received boolean');\n          });\n        });\n      });\n      describe('\"mode\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { mode: true });\n            }).to.throw('Argument \"criteria.mode\" passed to ' + test.methodName\n              + '(path, [criteria]) must be a string or a number. Received boolean');\n          });\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/find.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('find', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('returns list of relative paths anchored to CWD', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/file.txt', 'abc');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['a/b/file.txt']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('a', { matching: '*.txt' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('a', { matching: '*.txt' })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe('if recursive=false will exclude subfolders from search', function () {\n    var preparations = function () {\n      fse.outputFileSync('x/file.txt', 'abc');\n      fse.outputFileSync('x/y/file.txt', '123');\n      fse.outputFileSync('x/y/b/file.txt', '456');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['x/file.txt']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('x', { matching: '*.txt', recursive: false }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('x', { matching: '*.txt', recursive: false })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe('defaults to CWD if no path provided', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/file.txt', 'abc');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['a/b/file.txt']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find({ matching: '*.txt' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync({ matching: '*.txt' })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe('returns empty list if nothing found', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/c.md', 'abc');\n    };\n\n    var expectations = function (found) {\n      expect(found).to.eql([]);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('a', { matching: '*.txt' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('a', { matching: '*.txt' })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe('finds all paths which match globs', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/file.txt', '1');\n      fse.outputFileSync('a/b/c/file.txt', '2');\n      fse.outputFileSync('a/b/c/file.md', '3');\n      fse.outputFileSync('a/x/y/z', 'Zzzzz...');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep([\n        'a/b/c/file.txt',\n        'a/b/file.txt',\n        'a/x/y/z'\n      ]);\n      found.sort();\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('a', { matching: ['*.txt', 'z'] }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('a', { matching: ['*.txt', 'z'] })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe(\"anchors globs to directory you're finding in\", function () {\n    var preparations = function () {\n      fse.outputFileSync('x/y/a/b/file.txt', '123');\n      fse.outputFileSync('x/y/a/b/c/file.txt', '456');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['x/y/a/b/file.txt']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('x/y/a', { matching: 'b/*.txt' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('x/y/a', { matching: 'b/*.txt' })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe('can use ./ as indication of anchor directory', function () {\n    var preparations = function () {\n      fse.outputFileSync('x/y/file.txt', '123');\n      fse.outputFileSync('x/y/b/file.txt', '456');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['x/y/file.txt']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('x/y', { matching: './file.txt' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('x/y', { matching: './file.txt' })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe('deals with negation globs', function () {\n    var preparations = function () {\n      fse.outputFileSync('x/y/a/b', 'bbb');\n      fse.outputFileSync('x/y/a/x', 'xxx');\n      fse.outputFileSync('x/y/a/y', 'yyy');\n      fse.outputFileSync('x/y/a/z', 'zzz');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['x/y/a/b']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('x/y', {\n        matching: [\n          'a/*',\n          // Three different pattern types to test:\n          '!x',\n          '!a/y',\n          '!./a/z'\n        ]\n      }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('x/y', {\n        matching: [\n          'a/*',\n          // Three different pattern types to test:\n          '!x',\n          '!a/y',\n          '!./a/z'\n        ]\n      })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe(\"doesn't look for directories by default\", function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/foo1', 'abc');\n      fse.mkdirsSync('a/b/foo2');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['a/b/foo1']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('a', { matching: 'foo*' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('a', { matching: 'foo*' })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe('can look for files and directories', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/foo1', 'abc');\n      fse.mkdirsSync('a/b/foo2');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['a/b/foo1', 'a/b/foo2']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('a', {\n        matching: 'foo*',\n        directories: true\n      }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('a', {\n        matching: 'foo*',\n        directories: true\n      })\n      .then(function (found) {\n        expectations(found);\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('can look for only directories', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/foo1', 'abc');\n      fse.mkdirsSync('a/b/foo2');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['a/b/foo2']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('a', {\n        matching: 'foo*',\n        files: false,\n        directories: true\n      }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('a', {\n        matching: 'foo*',\n        files: false,\n        directories: true\n      })\n      .then(function (found) {\n        expectations(found);\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('looking for directories works ok with only negation globs in set', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/x', '123');\n      fse.outputFileSync('a/y', '789');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['a/x']);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('a', {\n        matching: ['!y'],\n        directories: true\n      }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('a', {\n        matching: ['!y'],\n        directories: true\n      })\n      .then(function (found) {\n        expectations(found);\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('when you turn off files and directoies returns empty list', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/foo1', 'abc');\n      fse.mkdirsSync('a/b/foo2');\n    };\n\n    var expectations = function (found) {\n      expect(found).to.eql([]);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find('a', {\n        matching: 'foo*',\n        files: false,\n        directories: false\n      }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('a', {\n        matching: 'foo*',\n        files: false,\n        directories: false\n      })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe(\"throws if path doesn't exist\", function () {\n    var expectations = function (err) {\n      expect(err.code).to.equal('ENOENT');\n      expect(err.message).to.have.string(\"Path you want to find stuff in doesn't exist\");\n    };\n\n    it('sync', function () {\n      try {\n        jetpack.find('a', { matching: '*.txt' });\n        throw new Error('Expected error to be thrown');\n      } catch (err) {\n        expectations(err);\n      }\n    });\n\n    it('async', function (done) {\n      jetpack.findAsync('a', { matching: '*.txt' })\n      .catch(function (err) {\n        expectations(err);\n        done();\n      });\n    });\n  });\n\n  describe('throws if path is a file, not a directory', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b', 'abc');\n    };\n\n    var expectations = function (err) {\n      expect(err.code).to.equal('ENOTDIR');\n      expect(err.message).to.have.string('Path you want to find stuff in must be a directory');\n    };\n\n    it('sync', function () {\n      preparations();\n      try {\n        jetpack.find('a/b', { matching: '*.txt' });\n        throw new Error('Expected error to be thrown');\n      } catch (err) {\n        expectations(err);\n      }\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync('a/b', { matching: '*.txt' })\n      .catch(function (err) {\n        expectations(err);\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/c/d.txt', 'abc');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep(['b/c/d.txt']); // NOT a/b/c/d.txt\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      expectations(jetContext.find('b', { matching: '*.txt' }));\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.findAsync('b', { matching: '*.txt' })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe('finds dot-dirs and dot-files', function () {\n    var preparations = function () {\n      fse.outputFileSync('.dir/file', 'a');\n      fse.outputFileSync('.dir/.file', 'b');\n      fse.outputFileSync('.foo/.file', 'c');\n    };\n\n    var expectations = function (found) {\n      var normalizedPaths = helper.osSep([\n        '.dir',\n        '.dir/.file'\n      ]);\n      expect(found).to.eql(normalizedPaths);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.find({\n        matching: ['.dir', '.file', '!.foo/**'],\n        directories: true\n      }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.findAsync({\n        matching: ['.dir', '.file', '!.foo/**'],\n        directories: true\n      })\n      .then(function (found) {\n        expectations(found);\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.find, methodName: 'find' },\n      { type: 'async', method: jetpack.findAsync, methodName: 'findAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined, {});\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '([path], options) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"options\" object', function () {\n      describe('\"matching\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method({ matching: 1 });\n            }).to.throw('Argument \"options.matching\" passed to ' + test.methodName\n              + '([path], options) must be a string or an array of string. Received number');\n          });\n        });\n      });\n      describe('\"files\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { files: 1 });\n            }).to.throw('Argument \"options.files\" passed to ' + test.methodName\n              + '([path], options) must be a boolean. Received number');\n          });\n        });\n      });\n      describe('\"directories\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { directories: 1 });\n            }).to.throw('Argument \"options.directories\" passed to ' + test.methodName\n              + '([path], options) must be a boolean. Received number');\n          });\n        });\n      });\n      describe('\"recursive\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { recursive: 1 });\n            }).to.throw('Argument \"options.recursive\" passed to ' + test.methodName\n              + '([path], options) must be a boolean. Received number');\n          });\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/helper.js":"/* eslint no-console:0 */\n\nvar os = require('os');\nvar crypto = require('crypto');\nvar fse = require('fs-extra');\n\nvar originalCwd = process.cwd();\nvar createdDirectories = [];\n\nprocess.on('exit', function () {\n  // In case something went wrong and some temp\n  // directories are still on the disk.\n  createdDirectories.forEach(function (path) {\n    fse.removeSync(path);\n  });\n});\n\nexports.setCleanTestCwd = function () {\n  var random = crypto.randomBytes(16).toString('hex');\n  var path = os.tmpdir() + '/fs-jetpack-test-' + random;\n  fse.mkdirSync(path);\n  createdDirectories.push(path);\n  process.chdir(path);\n};\n\nexports.switchBackToCorrectCwd = function () {\n  var path = createdDirectories.pop();\n  process.chdir(originalCwd);\n  fse.removeSync(path);\n};\n\nexports.parseMode = function (modeAsNumber) {\n  var mode = modeAsNumber.toString(8);\n  return mode.substring(mode.length - 3);\n};\n\n// Converts paths to windows or unix formats depending on platform running.\nexports.osSep = function (path) {\n  if (Array.isArray(path)) {\n    return path.map(exports.osSep);\n  }\n\n  if (process.platform === 'win32') {\n    return path.replace(/\\//g, '\\\\');\n  }\n  return path.replace(/\\\\/g, '/');\n};\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/inspect.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('inspect', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('can inspect a file', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/file.txt', 'abc');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql({\n        name: 'file.txt',\n        type: 'file',\n        size: 3\n      });\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspect('dir/file.txt'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectAsync('dir/file.txt')\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('can inspect a directory', function () {\n    var preparations = function () {\n      fse.mkdirsSync('empty');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql({\n        name: 'empty',\n        type: 'dir'\n      });\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspect('empty'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectAsync('empty')\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe(\"returns undefined if path doesn't exist\", function () {\n    var expectations = function (data) {\n      expect(data).to.equal(undefined);\n    };\n\n    it('sync', function () {\n      expectations(jetpack.inspect('nonexistent'));\n    });\n\n    it('async', function (done) {\n      jetpack.inspectAsync('nonexistent')\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('can output file times (ctime, mtime, atime)', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/file.txt', 'abc');\n    };\n\n    var expectations = function (data) {\n      expect(typeof data.accessTime.getTime).to.equal('function');\n      expect(typeof data.modifyTime.getTime).to.equal('function');\n      expect(typeof data.changeTime.getTime).to.equal('function');\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspect('dir/file.txt', { times: true }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectAsync('dir/file.txt', { times: true })\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('can output absolute path', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/file.txt', 'abc');\n    };\n\n    var expectations = function (data) {\n      expect(data.absolutePath).to.equal(jetpack.path('dir/file.txt'));\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspect('dir/file.txt', { absolutePath: true }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectAsync('dir/file.txt', { absolutePath: true })\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b.txt', 'abc');\n    };\n\n    var expectations = function (data) {\n      expect(data.name).to.equal('b.txt');\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      expectations(jetContext.inspect('b.txt'));\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.inspectAsync('b.txt')\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('reports symlink by default', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/file.txt', 'abc');\n      fse.symlinkSync('dir/file.txt', 'symlinked_file.txt');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql({\n        name: 'symlinked_file.txt',\n        type: 'symlink',\n        pointsAt: helper.osSep('dir/file.txt')\n      });\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspect('symlinked_file.txt')); // implicit\n      expectations(jetpack.inspect('symlinked_file.txt', { symlinks: 'report' })); // explicit\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectAsync('symlinked_file.txt') // implicit\n      .then(function (data) {\n        expectations(data);\n        return jetpack.inspectAsync('symlinked_file.txt', { symlinks: 'report' }); // explicit\n      })\n      .then(function (data) {\n        expectations(data);\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('follows symlink if option specified', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/file.txt', 'abc');\n      fse.symlinkSync('dir/file.txt', 'symlinked_file.txt');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql({\n        name: 'symlinked_file.txt',\n        type: 'file',\n        size: 3\n      });\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspect('symlinked_file.txt', { symlinks: 'follow' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectAsync('symlinked_file.txt', { symlinks: 'follow' })\n      .then(function (data) {\n        expectations(data);\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  if (process.platform !== 'win32') {\n    describe('can output file mode (unix only)', function () {\n      var preparations = function () {\n        fse.outputFileSync('dir/file.txt', 'abc', {\n          mode: '511'\n        });\n      };\n\n      var expectations = function (data) {\n        expect(helper.parseMode(data.mode)).to.equal('511');\n      };\n\n      it('sync', function () {\n        preparations();\n        expectations(jetpack.inspect('dir/file.txt', { mode: true }));\n      });\n\n      it('async', function (done) {\n        preparations();\n        jetpack.inspectAsync('dir/file.txt', { mode: true })\n        .then(function (data) {\n          expectations(data);\n          done();\n        });\n      });\n    });\n  }\n\n  describe('checksums', function () {\n    var testsData = [\n      {\n        name: 'md5',\n        type: 'md5',\n        content: 'abc',\n        expected: '900150983cd24fb0d6963f7d28e17f72'\n      },\n      {\n        name: 'sha1',\n        type: 'sha1',\n        content: 'abc',\n        expected: 'a9993e364706816aba3e25717850c26c9cd0d89d'\n      },\n      {\n        name: 'sha256',\n        type: 'sha256',\n        content: 'abc',\n        expected: 'ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad'\n      },\n      {\n        name: 'sha512',\n        type: 'sha512',\n        content: 'abc',\n        expected: 'ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a21'\n          + '92992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f'\n      },\n      {\n        name: 'calculates correctly checksum of an empty file',\n        type: 'md5',\n        content: '',\n        expected: 'd41d8cd98f00b204e9800998ecf8427e'\n      }\n    ];\n\n    testsData.forEach(function (test) {\n      describe(test.name, function () {\n        var preparations = function () {\n          fse.outputFileSync('file.txt', test.content);\n        };\n\n        var expectations = function (data) {\n          expect(data[test.type]).to.eql(test.expected);\n        };\n\n        it('sync', function () {\n          preparations();\n          expectations(jetpack.inspect('file.txt', { checksum: test.type }));\n        });\n\n        it('async', function (done) {\n          preparations();\n          jetpack.inspectAsync('file.txt', { checksum: test.type })\n          .then(function (data) {\n            expectations(data);\n            done();\n          })\n          .catch(done);\n        });\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.inspect, methodName: 'inspect' },\n      { type: 'async', method: jetpack.inspectAsync, methodName: 'inspectAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined);\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path, [options]) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"options\" object', function () {\n      describe('\"checksum\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { checksum: 1 });\n            }).to.throw('Argument \"options.checksum\" passed to ' + test.methodName\n              + '(path, [options]) must be a string. Received number');\n          });\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { checksum: 'foo' });\n            }).to.throw('Argument \"options.checksum\" passed to ' + test.methodName\n              + '(path, [options]) must have one of values: md5, sha1, sha256');\n          });\n        });\n      });\n      describe('\"mode\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { mode: 1 });\n            }).to.throw('Argument \"options.mode\" passed to ' + test.methodName\n              + '(path, [options]) must be a boolean. Received number');\n          });\n        });\n      });\n      describe('\"times\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { times: 1 });\n            }).to.throw('Argument \"options.times\" passed to ' + test.methodName\n              + '(path, [options]) must be a boolean. Received number');\n          });\n        });\n      });\n      describe('\"absolutePath\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { absolutePath: 1 });\n            }).to.throw('Argument \"options.absolutePath\" passed to ' + test.methodName\n              + '(path, [options]) must be a boolean. Received number');\n          });\n        });\n      });\n      describe('\"symlinks\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { symlinks: 1 });\n            }).to.throw('Argument \"options.symlinks\" passed to ' + test.methodName\n              + '(path, [options]) must be a string. Received number');\n          });\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { symlinks: 'foo' });\n            }).to.throw('Argument \"options.symlinks\" passed to ' + test.methodName\n              + '(path, [options]) must have one of values: report, follow');\n          });\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/inspect_tree.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('inspectTree', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('inspects whole tree of files', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/file.txt', 'abc');\n      fse.outputFileSync('dir/subdir/file.txt', 'defg');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql({\n        name: 'dir',\n        type: 'dir',\n        size: 7,\n        children: [\n          {\n            name: 'file.txt',\n            type: 'file',\n            size: 3\n          }, {\n            name: 'subdir',\n            type: 'dir',\n            size: 4,\n            children: [\n              {\n                name: 'file.txt',\n                type: 'file',\n                size: 4\n              }\n            ]\n          }\n        ]\n      });\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspectTree('dir'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectTreeAsync('dir')\n      .then(function (tree) {\n        expectations(tree);\n        done();\n      });\n    });\n  });\n\n  describe('can calculate size of a whole tree', function () {\n    var preparations = function () {\n      fse.mkdirsSync('dir/empty');\n      fse.outputFileSync('dir/empty.txt', '');\n      fse.outputFileSync('dir/file.txt', 'abc');\n      fse.outputFileSync('dir/subdir/file.txt', 'defg');\n    };\n\n    var expectations = function (data) {\n      // dir\n      expect(data.size).to.equal(7);\n      // dir/empty\n      expect(data.children[0].size).to.equal(0);\n      // dir/empty.txt\n      expect(data.children[1].size).to.equal(0);\n      // dir/file.txt\n      expect(data.children[2].size).to.equal(3);\n      // dir/subdir\n      expect(data.children[3].size).to.equal(4);\n      // dir/subdir/file.txt\n      expect(data.children[3].children[0].size).to.equal(4);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspectTree('dir'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectTreeAsync('dir')\n      .then(function (tree) {\n        expectations(tree);\n        done();\n      });\n    });\n  });\n\n  describe('can output relative path for every tree node', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/subdir/file.txt', 'defg');\n    };\n\n    var expectations = function (data) {\n      // data will look like...\n      // {\n      //   name: 'dir',\n      //   relativePath: '.',\n      //   children: [\n      //     {\n      //       name: 'subdir',\n      //       relativePath: './subdir',\n      //       children: [\n      //         {\n      //           name: 'file.txt',\n      //           relativePath: './subdir/file.txt'\n      //         }\n      //       ]\n      //     }\n      //   ]\n      // }\n      expect(data.relativePath).to.equal('.');\n      expect(data.children[0].relativePath).to.equal('./subdir');\n      expect(data.children[0].children[0].relativePath).to.equal('./subdir/file.txt');\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspectTree('dir', { relativePath: true }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectTreeAsync('dir', { relativePath: true })\n      .then(function (tree) {\n        expectations(tree);\n        done();\n      });\n    });\n  });\n\n  describe('if given path is a file just inspects that file', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/file.txt', 'abc');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql({\n        name: 'file.txt',\n        type: 'file',\n        size: 3\n      });\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspectTree('dir/file.txt'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectTreeAsync('dir/file.txt')\n      .then(function (tree) {\n        expectations(tree);\n        done();\n      });\n    });\n  });\n\n  describe('behaves ok with empty directory', function () {\n    var preparations = function () {\n      fse.mkdirsSync('empty');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql({\n        name: 'empty',\n        type: 'dir',\n        size: 0,\n        children: []\n      });\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspectTree('empty'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectTreeAsync('empty')\n      .then(function (tree) {\n        expectations(tree);\n        done();\n      });\n    });\n  });\n\n  describe(\"returns undefined if path doesn't exist\", function () {\n    var expectations = function (data) {\n      expect(data).to.equal(undefined);\n    };\n\n    it('sync', function () {\n      expectations(jetpack.inspectTree('nonexistent'));\n    });\n\n    it('async', function (done) {\n      jetpack.inspectTreeAsync('nonexistent')\n      .then(function (dataAsync) {\n        expectations(dataAsync);\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b.txt', 'abc');\n    };\n\n    var expectations = function (data) {\n      expect(data.name).to.equal('b.txt');\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      expectations(jetContext.inspectTree('b.txt'));\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.inspectTreeAsync('b.txt')\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('reports symlinks by default', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/file.txt', 'abc');\n      fse.symlinkSync('file.txt', 'dir/symlinked_file.txt');\n    };\n\n    var expectations = function (tree) {\n      expect(tree).to.eql({\n        name: 'dir',\n        type: 'dir',\n        size: 3,\n        children: [{\n          name: 'file.txt',\n          type: 'file',\n          size: 3\n        }, {\n          name: 'symlinked_file.txt',\n          type: 'symlink',\n          pointsAt: 'file.txt'\n        }]\n      });\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspectTree('dir')); // implicit\n      expectations(jetpack.inspectTree('dir', { symlinks: 'report' })); // explicit\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectTreeAsync('dir') // implicit\n      .then(function (tree) {\n        expectations(tree);\n        return jetpack.inspectTreeAsync('dir', { symlinks: 'report' }); // explicit\n      })\n      .then(function (tree) {\n        expectations(tree);\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('follows symlinks when option specified', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/file.txt', 'abc');\n      fse.symlinkSync('file.txt', 'dir/symlinked_file.txt');\n    };\n\n    var expectations = function (tree) {\n      expect(tree).to.eql({\n        name: 'dir',\n        type: 'dir',\n        size: 6,\n        children: [{\n          name: 'file.txt',\n          type: 'file',\n          size: 3\n        }, {\n          name: 'symlinked_file.txt',\n          type: 'file',\n          size: 3\n        }]\n      });\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspectTree('dir', { symlinks: 'follow' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectTreeAsync('dir', { symlinks: 'follow' })\n      .then(function (tree) {\n        expectations(tree);\n        done();\n      })\n      .catch(done);\n    });\n  });\n\n  describe('can compute checksum of a whole tree', function () {\n    var preparations = function () {\n      fse.outputFileSync('dir/a.txt', 'abc');\n      fse.outputFileSync('dir/b.txt', 'defg');\n    };\n\n    var expectations = function (data) {\n      // md5 of\n      // 'a.txt' + '900150983cd24fb0d6963f7d28e17f72' +\n      // 'b.txt' + '025e4da7edac35ede583f5e8d51aa7ec'\n      expect(data.md5).to.equal('b0ff9df854172efe752cb36b96c8bccd');\n      // md5 of 'abc'\n      expect(data.children[0].md5).to.equal('900150983cd24fb0d6963f7d28e17f72');\n      // md5 of 'defg'\n      expect(data.children[1].md5).to.equal('025e4da7edac35ede583f5e8d51aa7ec');\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspectTree('dir', { checksum: 'md5' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectTreeAsync('dir', { checksum: 'md5' })\n      .then(function (tree) {\n        expectations(tree);\n        done();\n      });\n    });\n  });\n\n  describe('can count checksum of empty directory', function () {\n    var preparations = function () {\n      fse.mkdirsSync('empty_dir');\n    };\n\n    var expectations = function (data) {\n      // md5 of empty string\n      expect(data.md5).to.equal('d41d8cd98f00b204e9800998ecf8427e');\n    };\n\n    // SYNC\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.inspectTree('empty_dir', { checksum: 'md5' }));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.inspectTreeAsync('empty_dir', { checksum: 'md5' })\n      .then(function (tree) {\n        expectations(tree);\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.inspectTree, methodName: 'inspectTree' },\n      { type: 'async', method: jetpack.inspectTreeAsync, methodName: 'inspectTreeAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined);\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path, [options]) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"options\" object', function () {\n      describe('\"checksum\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { checksum: 1 });\n            }).to.throw('Argument \"options.checksum\" passed to ' + test.methodName\n              + '(path, [options]) must be a string. Received number');\n          });\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { checksum: 'foo' });\n            }).to.throw('Argument \"options.checksum\" passed to ' + test.methodName\n              + '(path, [options]) must have one of values: md5, sha1, sha256');\n          });\n        });\n      });\n      describe('\"relativePath\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { relativePath: 1 });\n            }).to.throw('Argument \"options.relativePath\" passed to ' + test.methodName\n              + '(path, [options]) must be a boolean. Received number');\n          });\n        });\n      });\n      describe('\"symlinks\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { symlinks: 1 });\n            }).to.throw('Argument \"options.symlinks\" passed to ' + test.methodName\n              + '(path, [options]) must be a string. Received number');\n          });\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', { symlinks: 'foo' });\n            }).to.throw('Argument \"options.symlinks\" passed to ' + test.methodName\n              + '(path, [options]) must have one of values: report, follow');\n          });\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/list.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('list', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('lists file names in given path', function () {\n    var preparations = function () {\n      fse.mkdirsSync('dir/empty');\n      fse.outputFileSync('dir/empty.txt', '');\n      fse.outputFileSync('dir/file.txt', 'abc');\n      fse.outputFileSync('dir/subdir/file.txt', 'defg');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql(['empty', 'empty.txt', 'file.txt', 'subdir']);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.list('dir'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.listAsync('dir')\n      .then(function (listAsync) {\n        expectations(listAsync);\n        done();\n      });\n    });\n  });\n\n  describe('lists CWD if no path parameter passed', function () {\n    var preparations = function () {\n      fse.mkdirsSync('dir/a');\n      fse.outputFileSync('dir/b');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql(['a', 'b']);\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('dir');\n      preparations();\n      expectations(jetContext.list());\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('dir');\n      preparations();\n      jetContext.listAsync()\n      .then(function (list) {\n        expectations(list);\n        done();\n      });\n    });\n  });\n\n  describe(\"returns undefined if path doesn't exist\", function () {\n    var expectations = function (data) {\n      expect(data).to.equal(undefined);\n    };\n\n    it('sync', function () {\n      expectations(jetpack.list('nonexistent'));\n    });\n\n    it('async', function (done) {\n      jetpack.listAsync('nonexistent')\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('throws if given path is not a directory', function () {\n    var preparations = function () {\n      fse.outputFileSync('file.txt', 'abc');\n    };\n\n    var expectations = function (err) {\n      expect(err.code).to.equal('ENOTDIR');\n    };\n\n    it('sync', function () {\n      preparations();\n      try {\n        jetpack.list('file.txt');\n        throw new Error('Expected error to be thrown');\n      } catch (err) {\n        expectations(err);\n      }\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.listAsync('file.txt')\n      .catch(function (err) {\n        expectations(err);\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/c.txt', 'abc');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql(['c.txt']);\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      expectations(jetContext.list('b'));\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.listAsync('b')\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.list, methodName: 'list' },\n      { type: 'async', method: jetpack.listAsync, methodName: 'listAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(true);\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path) must be a string or an undefined. Received boolean');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/move.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('move', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('moves file', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a/b.txt').shouldNotExist();\n      path('c.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.move('a/b.txt', 'c.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.moveAsync('a/b.txt', 'c.txt')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('moves directory', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/c.txt', 'abc');\n      fse.mkdirsSync('x');\n    };\n\n    var expectations = function () {\n      path('a').shouldNotExist();\n      path('x/y/b/c.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.move('a', 'x/y');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.moveAsync('a', 'x/y')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('creates nonexistent directories for destination path', function () {\n    var preparations = function () {\n      fse.outputFileSync('a.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a.txt').shouldNotExist();\n      path('a/b/z.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.move('a.txt', 'a/b/z.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.moveAsync('a.txt', 'a/b/z.txt')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe(\"generates nice error when source path doesn't exist\", function () {\n    var expectations = function (err) {\n      expect(err.code).to.equal('ENOENT');\n      expect(err.message).to.have.string(\"Path to move doesn't exist\");\n    };\n\n    it('sync', function () {\n      try {\n        jetpack.move('a', 'b');\n        throw new Error('Expected error to be thrown');\n      } catch (err) {\n        expectations(err);\n      }\n    });\n\n    it('async', function (done) {\n      jetpack.moveAsync('a', 'b')\n      .catch(function (err) {\n        expectations(err);\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a/b.txt').shouldNotExist();\n      path('a/x.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.move('b.txt', 'x.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.moveAsync('b.txt', 'x.txt')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.move, methodName: 'move' },\n      { type: 'async', method: jetpack.moveAsync, methodName: 'moveAsync' }\n    ];\n\n    describe('\"from\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined, 'xyz');\n          }).to.throw('Argument \"from\" passed to ' + test.methodName\n            + '(from, to) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"to\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method('abc', undefined);\n          }).to.throw('Argument \"to\" passed to ' + test.methodName\n            + '(from, to) must be a string. Received undefined');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/path.spec.js":"var pathUtil = require('path');\nvar expect = require('chai').expect;\nvar jetpack = require('..');\n\ndescribe('path', function () {\n  it('if no parameters passed returns same path as cwd()', function () {\n    expect(jetpack.path()).to.equal(jetpack.cwd());\n    expect(jetpack.path('')).to.equal(jetpack.cwd());\n    expect(jetpack.path('.')).to.equal(jetpack.cwd());\n  });\n\n  it('is absolute if prepending slash present', function () {\n    expect(jetpack.path('/blah')).to.equal(pathUtil.resolve('/blah'));\n  });\n\n  it('resolves to CWD path of this jetpack instance', function () {\n    var a = pathUtil.join(jetpack.cwd(), 'a');\n    // Create jetpack instance with other CWD\n    var jetpackSubdir = jetpack.cwd('subdir');\n    var b = pathUtil.join(jetpack.cwd(), 'subdir', 'b');\n    expect(jetpack.path('a')).to.equal(a);\n    expect(jetpackSubdir.path('b')).to.equal(b);\n  });\n\n  it('can take unlimited number of arguments as path parts', function () {\n    var abc = pathUtil.join(jetpack.cwd(), 'a', 'b', 'c');\n    expect(jetpack.path('a', 'b', 'c')).to.equal(abc);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/read.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('read', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('reads file as a string', function () {\n    var preparations = function () {\n      fse.outputFileSync('file.txt', 'abc');\n    };\n\n    var expectations = function (content) {\n      expect(content).to.equal('abc');\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.read('file.txt')); // defaults to 'utf8'\n      expectations(jetpack.read('file.txt', 'utf8')); // explicitly specified\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.readAsync('file.txt') // defaults to 'utf8'\n      .then(function (content) {\n        expectations(content);\n        return jetpack.readAsync('file.txt', 'utf8'); // explicitly said\n      })\n      .then(function (content) {\n        expectations(content);\n        done();\n      });\n    });\n  });\n\n  describe('reads file as a Buffer', function () {\n    var preparations = function () {\n      fse.outputFileSync('file.txt', new Buffer([11, 22]));\n    };\n\n    var expectations = function (content) {\n      expect(Buffer.isBuffer(content)).to.equal(true);\n      expect(content.length).to.equal(2);\n      expect(content[0]).to.equal(11);\n      expect(content[1]).to.equal(22);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.read('file.txt', 'buffer'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.readAsync('file.txt', 'buffer')\n      .then(function (content) {\n        expectations(content);\n        done();\n      });\n    });\n  });\n\n  describe('reads file as JSON', function () {\n    var obj = {\n      utf8: 'ąćłźż'\n    };\n\n    var preparations = function () {\n      fse.outputFileSync('file.json', JSON.stringify(obj));\n    };\n\n    var expectations = function (content) {\n      expect(content).to.eql(obj);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.read('file.json', 'json'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.readAsync('file.json', 'json')\n      .then(function (content) {\n        expectations(content);\n        done();\n      });\n    });\n  });\n\n  describe('gives nice error message when JSON parsing failed', function () {\n    var preparations = function () {\n      fse.outputFileSync('file.json', '{ \"abc: 123 }'); // Malformed JSON\n    };\n\n    var expectations = function (err) {\n      expect(err.message).to.have.string('JSON parsing failed while reading');\n    };\n\n    it('sync', function () {\n      preparations();\n      try {\n        jetpack.read('file.json', 'json');\n        throw new Error('Expected error to be thrown');\n      } catch (err) {\n        expectations(err);\n      }\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.readAsync('file.json', 'json')\n      .catch(function (err) {\n        expectations(err);\n        done();\n      });\n    });\n  });\n\n  describe('reads file as JSON with Date parsing', function () {\n    var obj = {\n      utf8: 'ąćłźż',\n      date: new Date()\n    };\n\n    var preparations = function () {\n      fse.outputFileSync('file.json', JSON.stringify(obj));\n    };\n\n    var expectations = function (content) {\n      expect(content).to.eql(obj);\n    };\n\n    it('sync', function () {\n      preparations();\n      expectations(jetpack.read('file.json', 'jsonWithDates'));\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.readAsync('file.json', 'jsonWithDates')\n      .then(function (content) {\n        expectations(content);\n        done();\n      });\n    });\n  });\n\n  describe(\"returns undefined if file doesn't exist\", function () {\n    var expectations = function (content) {\n      expect(content).to.equal(undefined);\n    };\n\n    it('sync', function () {\n      expectations(jetpack.read('nonexistent.txt'));\n      expectations(jetpack.read('nonexistent.txt', 'json'));\n      expectations(jetpack.read('nonexistent.txt', 'buffer'));\n    });\n\n    it('async', function (done) {\n      jetpack.readAsync('nonexistent.txt')\n      .then(function (content) {\n        expectations(content);\n        return jetpack.readAsync('nonexistent.txt', 'json');\n      })\n      .then(function (content) {\n        expectations(content);\n        return jetpack.readAsync('nonexistent.txt', 'buffer');\n      })\n      .then(function (content) {\n        expectations(content);\n        done();\n      });\n    });\n  });\n\n  describe('throws if given path is a directory', function () {\n    var preparations = function () {\n      fse.mkdirsSync('dir');\n    };\n\n    var expectations = function (err) {\n      expect(err.code).to.equal('EISDIR');\n    };\n\n    it('sync', function () {\n      preparations();\n      try {\n        jetpack.read('dir');\n        throw new Error('Expected error to be thrown');\n      } catch (err) {\n        expectations(err);\n      }\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.readAsync('dir')\n      .catch(function (err) {\n        expectations(err);\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/file.txt', 'abc');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.equal('abc');\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      expectations(jetContext.read('file.txt'));\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.readAsync('file.txt')\n      .then(function (data) {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.read, methodName: 'read' },\n      { type: 'async', method: jetpack.readAsync, methodName: 'readAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined, 'xyz');\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path, returnAs) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"returnAs\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method('abc', true);\n          }).to.throw('Argument \"returnAs\" passed to ' + test.methodName\n            + '(path, returnAs) must be a string or an undefined. Received boolean');\n          expect(function () {\n            test.method('abc', 'foo');\n          }).to.throw('Argument \"returnAs\" passed to ' + test.methodName\n            + '(path, returnAs) must have one of values: utf8, buffer, json, jsonWithDates');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/remove.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('remove', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe(\"doesn't throw if path already doesn't exist\", function () {\n    it('sync', function () {\n      jetpack.remove('dir');\n    });\n\n    it('async', function (done) {\n      jetpack.removeAsync('dir')\n      .then(function () {\n        done();\n      });\n    });\n  });\n\n  describe('should delete file', function () {\n    var preparations = function () {\n      fse.outputFileSync('file.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('file.txt').shouldNotExist();\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.remove('file.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.removeAsync('file.txt')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('removes directory with stuff inside', function () {\n    var preparations = function () {\n      fse.mkdirsSync('a/b/c');\n      fse.outputFileSync('a/f.txt', 'abc');\n      fse.outputFileSync('a/b/f.txt', '123');\n    };\n\n    var expectations = function () {\n      path('a').shouldNotExist();\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.remove('a');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.removeAsync('a')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('will retry attempt if file is locked', function () {\n    var preparations = function () {\n      fse.mkdirsSync('a/b/c');\n      fse.outputFileSync('a/f.txt', 'abc');\n      fse.outputFileSync('a/b/f.txt', '123');\n    };\n\n    var expectations = function () {\n      path('a').shouldNotExist();\n    };\n\n    it('async', function (done) {\n      preparations();\n\n      fse.open('a/f.txt', 'w', function (err, fd) {\n        if (err) {\n          done(err);\n        } else {\n          // Unlock the file after some time.\n          setTimeout(function () {\n            fse.close(fd);\n          }, 150);\n\n          jetpack.removeAsync('a')\n          .then(function () {\n            expectations();\n            done();\n          })\n          .catch(done);\n        }\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/c.txt', '123');\n    };\n\n    var expectations = function () {\n      path('a').shouldBeDirectory();\n      path('a/b').shouldNotExist();\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.remove('b');\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.removeAsync('b')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('can be called with no parameters, what will remove CWD directory', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/c.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a').shouldNotExist();\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.remove();\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.removeAsync()\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('removes only symlinks, never real content where symlinks point', function () {\n    var preparations = function () {\n      fse.outputFileSync('have_to_stay_file', 'abc');\n      fse.mkdirsSync('to_remove');\n      fse.symlinkSync('../have_to_stay_file', 'to_remove/symlink');\n      // Make sure we symlinked it properly.\n      expect(fse.readFileSync('to_remove/symlink', 'utf8')).to.equal('abc');\n    };\n\n    var expectations = function () {\n      path('have_to_stay_file').shouldBeFileWithContent('abc');\n      path('to_remove').shouldNotExist();\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.remove('to_remove');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.removeAsync('to_remove')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.remove, methodName: 'remove' },\n      { type: 'async', method: jetpack.removeAsync, methodName: 'removeAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(true);\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '([path]) must be a string or an undefined. Received boolean');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/rename.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('rename', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('renames file', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a/b.txt').shouldNotExist();\n      path('a/x.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.rename('a/b.txt', 'x.txt');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.renameAsync('a/b.txt', 'x.txt')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('renames directory', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/c.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a/b').shouldNotExist();\n      path('a/x').shouldBeDirectory();\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.rename('a/b', 'x');\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.renameAsync('a/b', 'x')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/c.txt', 'abc');\n    };\n\n    var expectations = function () {\n      path('a/b').shouldNotExist();\n      path('a/x').shouldBeDirectory();\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.rename('b', 'x');\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      preparations();\n      jetContext.renameAsync('b', 'x')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.rename, methodName: 'rename' },\n      { type: 'async', method: jetpack.renameAsync, methodName: 'renameAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined, 'xyz');\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path, newName) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"newName\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method('abc', undefined);\n          }).to.throw('Argument \"newName\" passed to ' + test.methodName\n            + '(path, newName) must be a string. Received undefined');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/streams.spec.js":"var fse = require('fs-extra');\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('streams', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  it('exposes vanilla stream methods', function (done) {\n    var input;\n    var output;\n\n    fse.outputFileSync('a.txt', 'abc');\n\n    input = jetpack.createReadStream('a.txt');\n    output = jetpack.createWriteStream('b.txt');\n    output.on('finish', function () {\n      path('b.txt').shouldBeFileWithContent('abc');\n      done();\n    });\n    input.pipe(output);\n  });\n\n  it('stream methods respect jetpack internal CWD', function (done) {\n    var input;\n    var output;\n\n    var dir = jetpack.cwd('dir');\n\n    fse.outputFileSync('dir/a.txt', 'abc');\n\n    input = dir.createReadStream('a.txt');\n    output = dir.createWriteStream('b.txt');\n    output.on('finish', function () {\n      path('dir/b.txt').shouldBeFileWithContent('abc');\n      done();\n    });\n    input.pipe(output);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/symlink.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('symlink', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('can create a symlink', function () {\n    var expectations = function () {\n      expect(fse.lstatSync('symlink').isSymbolicLink()).to.equal(true);\n      expect(fse.readlinkSync('symlink')).to.equal('some_path');\n    };\n\n    it('sync', function () {\n      jetpack.symlink('some_path', 'symlink');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.symlinkAsync('some_path', 'symlink')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('can create nonexistent parent directories', function () {\n    var expectations = function () {\n      expect(fse.lstatSync('a/b/symlink').isSymbolicLink()).to.equal(true);\n    };\n\n    it('sync', function () {\n      jetpack.symlink('whatever', 'a/b/symlink');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.symlinkAsync('whatever', 'a/b/symlink')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var preparations = function () {\n      fse.mkdirsSync('a/b');\n    };\n\n    var expectations = function () {\n      expect(fse.lstatSync('a/b/symlink').isSymbolicLink()).to.equal(true);\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a/b');\n      preparations();\n      jetContext.symlink('whatever', 'symlink');\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a/b');\n      preparations();\n      jetContext.symlinkAsync('whatever', 'symlink')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.symlink, methodName: 'symlink' },\n      { type: 'async', method: jetpack.symlinkAsync, methodName: 'symlinkAsync' }\n    ];\n\n    describe('\"symlinkValue\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined, 'abc');\n          }).to.throw('Argument \"symlinkValue\" passed to ' + test.methodName\n            + '(symlinkValue, path) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method('xyz', undefined);\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(symlinkValue, path) must be a string. Received undefined');\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/write_atomic.spec.js":"var fse = require('fs-extra');\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('atomic write', function () {\n  var filePath = 'file.txt';\n  var tempPath = filePath + '.__new__';\n\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe(\"fresh write (file doesn't exist yet)\", function () {\n    var expectations = function () {\n      path(filePath).shouldBeFileWithContent('abc');\n      path(tempPath).shouldNotExist();\n    };\n\n    it('sync', function () {\n      jetpack.write(filePath, 'abc', { atomic: true });\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.writeAsync(filePath, 'abc', { atomic: true })\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('overwrite existing file', function () {\n    var preparations = function () {\n      fse.outputFileSync(filePath, 'xyz');\n    };\n\n    var expectations = function () {\n      path(filePath).shouldBeFileWithContent('abc');\n      path(tempPath).shouldNotExist();\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.write(filePath, 'abc', { atomic: true });\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.writeAsync(filePath, 'abc', { atomic: true })\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('if previous operation failed', function () {\n    var preparations = function () {\n      fse.outputFileSync(filePath, 'xyz');\n      // Simulating remained file from interrupted previous write attempt.\n      fse.outputFileSync(tempPath, '123');\n    };\n\n    var expectations = function () {\n      path(filePath).shouldBeFileWithContent('abc');\n      path(tempPath).shouldNotExist();\n    };\n\n    it('sync', function () {\n      preparations();\n      jetpack.write(filePath, 'abc', { atomic: true });\n      expectations();\n    });\n\n    it('async', function (done) {\n      preparations();\n      jetpack.writeAsync(filePath, 'abc', { atomic: true })\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/write.spec.js":"var fse = require('fs-extra');\nvar expect = require('chai').expect;\nvar path = require('./assert_path');\nvar helper = require('./helper');\nvar jetpack = require('..');\n\ndescribe('write', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('writes data from string', function () {\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      jetpack.write('file.txt', 'abc');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.writeAsync('file.txt', 'abc')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('writes data from Buffer', function () {\n    var expectations = function () {\n      path('file.txt').shouldBeFileWithContent(new Buffer([11, 22]));\n    };\n\n    it('sync', function () {\n      jetpack.write('file.txt', new Buffer([11, 22]));\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.writeAsync('file.txt', new Buffer([11, 22]))\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('writes data as JSON', function () {\n    var obj = {\n      utf8: 'ąćłźż'\n    };\n\n    var expectations = function () {\n      var content = JSON.parse(fse.readFileSync('file.json', 'utf8'));\n      expect(content).to.eql(obj);\n    };\n\n    it('sync', function () {\n      jetpack.write('file.json', obj);\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.writeAsync('file.json', obj)\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('written JSON data can be indented', function () {\n    var obj = {\n      utf8: 'ąćłźż'\n    };\n\n    var expectations = function () {\n      var sizeA = fse.statSync('a.json').size;\n      var sizeB = fse.statSync('b.json').size;\n      var sizeC = fse.statSync('c.json').size;\n      expect(sizeB).to.be.above(sizeA);\n      expect(sizeC).to.be.above(sizeB);\n    };\n\n    it('sync', function () {\n      jetpack.write('a.json', obj, { jsonIndent: 0 });\n      jetpack.write('b.json', obj); // Default indent = 2\n      jetpack.write('c.json', obj, { jsonIndent: 4 });\n      expectations();\n    });\n\n    it('async', function (done) {\n      Promise.all([\n        jetpack.writeAsync('a.json', obj, { jsonIndent: 0 }),\n        jetpack.writeAsync('b.json', obj), // Default indent = 2\n        jetpack.writeAsync('c.json', obj, { jsonIndent: 4 })\n      ])\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('writes and reads file as JSON with Date parsing', function () {\n    var obj = {\n      date: new Date()\n    };\n\n    var expectations = function () {\n      var content = JSON.parse(fse.readFileSync('file.json', 'utf8'));\n      expect(content.date).to.equal(obj.date.toISOString());\n    };\n\n    it('sync', function () {\n      jetpack.write('file.json', obj);\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.writeAsync('file.json', obj)\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('can create nonexistent parent directories', function () {\n    var expectations = function () {\n      path('a/b/c.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      jetpack.write('a/b/c.txt', 'abc');\n      expectations();\n    });\n\n    it('async', function (done) {\n      jetpack.writeAsync('a/b/c.txt', 'abc')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('respects internal CWD of jetpack instance', function () {\n    var expectations = function () {\n      path('a/b/c.txt').shouldBeFileWithContent('abc');\n    };\n\n    it('sync', function () {\n      var jetContext = jetpack.cwd('a');\n      jetContext.write('b/c.txt', 'abc');\n      expectations();\n    });\n\n    it('async', function (done) {\n      var jetContext = jetpack.cwd('a');\n      jetContext.writeAsync('b/c.txt', 'abc')\n      .then(function () {\n        expectations();\n        done();\n      });\n    });\n  });\n\n  describe('input validation', function () {\n    var tests = [\n      { type: 'sync', method: jetpack.write, methodName: 'write' },\n      { type: 'async', method: jetpack.writeAsync, methodName: 'writeAsync' }\n    ];\n\n    describe('\"path\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method(undefined);\n          }).to.throw('Argument \"path\" passed to ' + test.methodName\n            + '(path, data, [options]) must be a string. Received undefined');\n        });\n      });\n    });\n\n    describe('\"data\" argument', function () {\n      tests.forEach(function (test) {\n        it(test.type, function () {\n          expect(function () {\n            test.method('abc', true);\n          }).to.throw('Argument \"data\" passed to ' + test.methodName\n            + '(path, data, [options]) must be a string or a buffer or an object or '\n            + 'an array. Received boolean');\n        });\n      });\n    });\n\n    describe('\"options\" object', function () {\n      describe('\"atomic\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', 'xyz', { atomic: 1 });\n            }).to.throw('Argument \"options.atomic\" passed to ' + test.methodName\n              + '(path, data, [options]) must be a boolean. Received number');\n          });\n        });\n      });\n      describe('\"jsonIndent\" argument', function () {\n        tests.forEach(function (test) {\n          it(test.type, function () {\n            expect(function () {\n              test.method('abc', 'xyz', { jsonIndent: true });\n            }).to.throw('Argument \"options.jsonIndent\" passed to ' + test.methodName\n              + '(path, data, [options]) must be a number. Received boolean');\n          });\n        });\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/utils/fs.spec.js":"var fsNode = require('fs');\nvar expect = require('chai').expect;\nvar fs = require('../../lib/utils/fs');\n\ndescribe('fs', function () {\n  it('contains all the same keys as the node fs module', function () {\n    var originalKeys = Object.keys(fsNode);\n    var adaptedKeys = Object.keys(fs);\n    expect(adaptedKeys).to.deep.equal(originalKeys);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/utils/matcher.spec.js":"var expect = require('chai').expect;\nvar matcher = require('../../lib/utils/matcher');\n\ndescribe('matcher', function () {\n  it('can test against one pattern passed as a string', function () {\n    var test = matcher.create('/', 'a');\n    expect(test('/a')).to.equal(true);\n    expect(test('/b')).to.equal(false);\n  });\n\n  it('can test against many patterns passed as an array', function () {\n    var test = matcher.create('/', ['a', 'b']);\n    expect(test('/a')).to.equal(true);\n    expect(test('/b')).to.equal(true);\n    expect(test('/c')).to.equal(false);\n  });\n\n  describe('pattern types', function () {\n    it('only basename', function () {\n      var test = matcher.create('/', 'a');\n      expect(test('/a')).to.equal(true);\n      expect(test('/b/a')).to.equal(true);\n      expect(test('/a/b')).to.equal(false);\n    });\n\n    it('absolute', function () {\n      var test = matcher.create('/', ['/b']);\n      expect(test('/b')).to.equal(true);\n      expect(test('/a/b')).to.equal(false);\n      test = matcher.create('/a', ['/b']);\n      expect(test('/a/b')).to.equal(false);\n    });\n\n    it('relative with ./', function () {\n      var test = matcher.create('/a', ['./b']);\n      expect(test('/a/b')).to.equal(true);\n      expect(test('/b')).to.equal(false);\n    });\n\n    it('relative (because has slash inside)', function () {\n      var test = matcher.create('/a', ['b/c']);\n      expect(test('/a/b/c')).to.equal(true);\n      expect(test('/b/c')).to.equal(false);\n    });\n  });\n\n  describe('possible tokens', function () {\n    it('*', function () {\n      var test = matcher.create('/', ['*']);\n      expect(test('/a')).to.equal(true);\n      expect(test('/a/b.txt')).to.equal(true);\n\n      test = matcher.create('/', ['a*b']);\n      expect(test('/ab')).to.equal(true);\n      expect(test('/a_b')).to.equal(true);\n      expect(test('/a__b')).to.equal(true);\n    });\n\n    it('**', function () {\n      var test = matcher.create('/', ['**']);\n      expect(test('/a')).to.equal(true);\n      expect(test('/a/b')).to.equal(true);\n\n      test = matcher.create('/', ['a/**/d']);\n      expect(test('/a/d')).to.equal(true);\n      expect(test('/a/b/d')).to.equal(true);\n      expect(test('/a/b/c/d')).to.equal(true);\n      expect(test('/a')).to.equal(false);\n      expect(test('/d')).to.equal(false);\n    });\n\n    it('**/something', function () {\n      var test = matcher.create('/', ['**/a']);\n      expect(test('/a')).to.equal(true);\n      expect(test('/x/a')).to.equal(true);\n      expect(test('/x/y/a')).to.equal(true);\n      expect(test('/a/b')).to.equal(false);\n    });\n\n    it('@(pattern|pattern) - exactly one of patterns', function () {\n      var test = matcher.create('/', ['@(foo|bar)']);\n      expect(test('/foo')).to.equal(true);\n      expect(test('/bar')).to.equal(true);\n      expect(test('/foobar')).to.equal(false);\n    });\n\n    it('+(pattern|pattern) - one or more of patterns', function () {\n      var test = matcher.create('/', ['+(foo|bar)']);\n      expect(test('/foo')).to.equal(true);\n      expect(test('/bar')).to.equal(true);\n      expect(test('/foobar')).to.equal(true);\n      expect(test('/foobarbaz')).to.equal(false);\n    });\n\n    it('?(pattern|pattern) - zero or one of patterns', function () {\n      var test = matcher.create('/', ['?(foo|bar)1']);\n      expect(test('/1')).to.equal(true);\n      expect(test('/foo1')).to.equal(true);\n      expect(test('/bar1')).to.equal(true);\n      expect(test('/foobar1')).to.equal(false);\n    });\n\n    it('*(pattern|pattern) - zero or more of patterns', function () {\n      var test = matcher.create('/', ['*(foo|bar)1']);\n      expect(test('/1')).to.equal(true);\n      expect(test('/foo1')).to.equal(true);\n      expect(test('/bar1')).to.equal(true);\n      expect(test('/foobar1')).to.equal(true);\n      expect(test('/barfoo1')).to.equal(true);\n      expect(test('/foofoo1')).to.equal(true);\n    });\n\n    it('{a,b}', function () {\n      var test = matcher.create('/', ['*.{jpg,png}']);\n      expect(test('a.jpg')).to.equal(true);\n      expect(test('b.png')).to.equal(true);\n      expect(test('c.txt')).to.equal(false);\n    });\n\n    it('?', function () {\n      var test = matcher.create('/', ['a?c']);\n      expect(test('/abc')).to.equal(true);\n      expect(test('/ac')).to.equal(false);\n      expect(test('/abbc')).to.equal(false);\n    });\n\n    it('[...] - characters range', function () {\n      var test = matcher.create('/', ['[0-9][0-9]']);\n      expect(test('/78')).to.equal(true);\n      expect(test('/a78')).to.equal(false);\n    });\n\n    it('combining different tokens together', function () {\n      var test = matcher.create('/', ['+(f?o|bar*)']);\n      expect(test('/f0o')).to.equal(true);\n      expect(test('/f_o')).to.equal(true);\n      expect(test('/bar')).to.equal(true);\n      expect(test('/bar_')).to.equal(true);\n      expect(test('/f_obar123')).to.equal(true);\n      expect(test('/f__obar123')).to.equal(false);\n    });\n\n    it('comment character # has no special meaning', function () {\n      var test = matcher.create('/', ['#a']);\n      expect(test('/#a')).to.equal(true);\n    });\n  });\n\n  describe('negation', function () {\n    it('selects everything except negated', function () {\n      var test = matcher.create('/', '!abc');\n      expect(test('/abc')).to.equal(false);\n      expect(test('/xyz')).to.equal(true);\n    });\n\n    it('selects everything except negated (multiple patterns)', function () {\n      var test = matcher.create('/', ['!abc', '!xyz']);\n      expect(test('/abc')).to.equal(false);\n      expect(test('/xyz')).to.equal(false);\n      expect(test('/whatever')).to.equal(true);\n    });\n\n    it('filters previous match if negation is farther in order', function () {\n      var test = matcher.create('/', ['abc', '123', '!/xyz/**', '!789/**']);\n      expect(test('/abc')).to.equal(true);\n      expect(test('/456/123')).to.equal(true);\n      expect(test('/xyz/abc')).to.equal(false);\n      expect(test('/789/123')).to.equal(false);\n      expect(test('/whatever')).to.equal(false);\n    });\n  });\n\n  describe('dotfiles', function () {\n    it('has no problem with matching dotfile', function () {\n      var test = matcher.create('/', '.foo');\n      expect(test('/.foo')).to.equal(true);\n      expect(test('/foo')).to.equal(false);\n    });\n\n    it('dotfile negation', function () {\n      var test = matcher.create('/', ['abc', '!.foo/**']);\n      expect(test('/.foo/abc')).to.equal(false);\n      test = matcher.create('/', ['abc', '!.foo/**']);\n      expect(test('/foo/abc')).to.equal(true);\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/utils/tree_walker.spec.js":"/* eslint no-console:0 */\n\nvar fse = require('fs-extra');\nvar pathUtil = require('path');\nvar expect = require('chai').expect;\nvar helper = require('../helper');\nvar walker = require('../../lib/utils/tree_walker');\n\ndescribe('tree walker', function () {\n  beforeEach(helper.setCleanTestCwd);\n  afterEach(helper.switchBackToCorrectCwd);\n\n  describe('inspects all files and folders recursively and returns them one by one', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/a.txt', 'a');\n      fse.outputFileSync('a/b/z1.txt', 'z1');\n      fse.outputFileSync('a/b/z2.txt', 'z2');\n      fse.mkdirsSync('a/b/c');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql([\n        {\n          path: pathUtil.resolve('a'),\n          item: {\n            type: 'dir',\n            name: 'a'\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'a.txt'),\n          item: {\n            type: 'file',\n            name: 'a.txt',\n            size: 1\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'b'),\n          item: {\n            type: 'dir',\n            name: 'b'\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'b', 'c'),\n          item: {\n            type: 'dir',\n            name: 'c'\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'b', 'z1.txt'),\n          item: {\n            type: 'file',\n            name: 'z1.txt',\n            size: 2\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'b', 'z2.txt'),\n          item: {\n            type: 'file',\n            name: 'z2.txt',\n            size: 2\n          }\n        }\n      ]);\n    };\n\n    it('sync', function () {\n      var absoluteStartingPath = pathUtil.resolve('a');\n      var data = [];\n      preparations();\n      walker.sync(absoluteStartingPath, {}, function (path, item) {\n        data.push({ path: path, item: item });\n      });\n      expectations(data);\n    });\n\n    it('async', function (done) {\n      var absoluteStartingPath = pathUtil.resolve('a');\n      var data = [];\n      var st;\n      preparations();\n      st = walker.stream(absoluteStartingPath, {})\n      .on('readable', function () {\n        var a = st.read();\n        if (a) {\n          data.push(a);\n        }\n      })\n      .on('error', console.error)\n      .on('end', function () {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('can walk through many nested directories', function () {\n    var preparations = function () {\n      fse.outputFileSync('a/b/x/z1.txt', 'z1');\n      fse.outputFileSync('a/c/y/z2.txt', 'z2');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql([\n        {\n          path: pathUtil.resolve('a'),\n          item: {\n            type: 'dir',\n            name: 'a'\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'b'),\n          item: {\n            type: 'dir',\n            name: 'b'\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'b', 'x'),\n          item: {\n            type: 'dir',\n            name: 'x'\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'b', 'x', 'z1.txt'),\n          item: {\n            type: 'file',\n            name: 'z1.txt',\n            size: 2\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'c'),\n          item: {\n            type: 'dir',\n            name: 'c'\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'c', 'y'),\n          item: {\n            type: 'dir',\n            name: 'y'\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'c', 'y', 'z2.txt'),\n          item: {\n            type: 'file',\n            name: 'z2.txt',\n            size: 2\n          }\n        }\n      ]);\n    };\n\n    it('sync', function () {\n      var absoluteStartingPath = pathUtil.resolve('a');\n      var data = [];\n      preparations();\n      walker.sync(absoluteStartingPath, {}, function (path, item) {\n        data.push({ path: path, item: item });\n      });\n      expectations(data);\n    });\n\n    it('async', function (done) {\n      var absoluteStartingPath = pathUtil.resolve('a');\n      var data = [];\n      var st;\n      preparations();\n      st = walker.stream(absoluteStartingPath, {})\n      .on('readable', function () {\n        var a = st.read();\n        if (a) {\n          data.push(a);\n        }\n      })\n      .on('error', console.error)\n      .on('end', function () {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n\n  describe(\"won't penetrate folder tree deeper than maxLevelsDeep option tells\", function () {\n    var options = {\n      maxLevelsDeep: 1\n    };\n\n    var preparations = function () {\n      fse.outputFileSync('a/a.txt', 'a');\n      fse.outputFileSync('a/b/z1.txt', 'z1');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql([\n        {\n          path: pathUtil.resolve('a'),\n          item: {\n            type: 'dir',\n            name: 'a'\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'a.txt'),\n          item: {\n            type: 'file',\n            name: 'a.txt',\n            size: 1\n          }\n        },\n        {\n          path: pathUtil.resolve('a', 'b'),\n          item: {\n            type: 'dir',\n            name: 'b'\n          }\n        }\n      ]);\n    };\n\n    it('sync', function () {\n      var absoluteStartingPath = pathUtil.resolve('a');\n      var data = [];\n      preparations();\n      walker.sync(absoluteStartingPath, options, function (path, item) {\n        data.push({ path: path, item: item });\n      });\n      expectations(data);\n    });\n\n    it('async', function (done) {\n      var absoluteStartingPath = pathUtil.resolve('a');\n      var data = [];\n      var st;\n      preparations();\n      st = walker.stream(absoluteStartingPath, options)\n      .on('readable', function () {\n        var a = st.read();\n        if (a) {\n          data.push(a);\n        }\n      })\n      .on('error', console.error)\n      .on('end', function () {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('will do fine with empty directory as entry point', function () {\n    var preparations = function () {\n      fse.mkdirsSync('abc');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql([\n        {\n          path: pathUtil.resolve('abc'),\n          item: {\n            type: 'dir',\n            name: 'abc'\n          }\n        }\n      ]);\n    };\n\n    it('sync', function () {\n      var absoluteStartingPath = pathUtil.resolve('abc');\n      var data = [];\n      preparations();\n      walker.sync(absoluteStartingPath, {}, function (path, item) {\n        data.push({ path: path, item: item });\n      });\n      expectations(data);\n    });\n\n    it('async', function (done) {\n      var absoluteStartingPath = pathUtil.resolve('abc');\n      var data = [];\n      var st;\n      preparations();\n      st = walker.stream(absoluteStartingPath, {})\n      .on('readable', function () {\n        var a = st.read();\n        if (a) {\n          data.push(a);\n        }\n      })\n      .on('error', console.error)\n      .on('end', function () {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('will do fine with file as entry point', function () {\n    var preparations = function () {\n      fse.outputFileSync('abc.txt', 'abc');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql([\n        {\n          path: pathUtil.resolve('abc.txt'),\n          item: {\n            type: 'file',\n            name: 'abc.txt',\n            size: 3\n          }\n        }\n      ]);\n    };\n\n    it('sync', function () {\n      var absoluteStartingPath = pathUtil.resolve('abc.txt');\n      var data = [];\n      preparations();\n      walker.sync(absoluteStartingPath, {}, function (path, item) {\n        data.push({ path: path, item: item });\n      });\n      expectations(data);\n    });\n\n    it('async', function (done) {\n      var absoluteStartingPath = pathUtil.resolve('abc.txt');\n      var data = [];\n      var st;\n      preparations();\n      st = walker.stream(absoluteStartingPath, {})\n      .on('readable', function () {\n        var a = st.read();\n        if (a) {\n          data.push(a);\n        }\n      })\n      .on('error', console.error)\n      .on('end', function () {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('will do fine with nonexistent entry point', function () {\n    var expectations = function (data) {\n      expect(data).to.eql([\n        {\n          path: pathUtil.resolve('abc.txt'),\n          item: undefined\n        }\n      ]);\n    };\n\n    it('sync', function () {\n      var absoluteStartingPath = pathUtil.resolve('abc.txt');\n      var data = [];\n      walker.sync(absoluteStartingPath, {}, function (path, item) {\n        data.push({ path: path, item: item });\n      });\n      expectations(data);\n    });\n\n    it('async', function (done) {\n      var absoluteStartingPath = pathUtil.resolve('abc.txt');\n      var data = [];\n      var st;\n      st = walker.stream(absoluteStartingPath, {})\n      .on('readable', function () {\n        var a = st.read();\n        if (a) {\n          data.push(a);\n        }\n      })\n      .on('error', console.error)\n      .on('end', function () {\n        expectations(data);\n        done();\n      });\n    });\n  });\n\n  describe('supports inspect options', function () {\n    var options = {\n      inspectOptions: {\n        checksum: 'md5'\n      }\n    };\n\n    var preparations = function () {\n      fse.outputFileSync('abc/a.txt', 'a');\n    };\n\n    var expectations = function (data) {\n      expect(data).to.eql([\n        {\n          path: pathUtil.resolve('abc'),\n          item: {\n            type: 'dir',\n            name: 'abc'\n          }\n        },\n        {\n          path: pathUtil.resolve('abc', 'a.txt'),\n          item: {\n            type: 'file',\n            name: 'a.txt',\n            size: 1,\n            md5: '0cc175b9c0f1b6a831c399e269772661'\n          }\n        }\n      ]);\n    };\n\n    it('sync', function () {\n      var absoluteStartingPath = pathUtil.resolve('abc');\n      var data = [];\n      preparations();\n      walker.sync(absoluteStartingPath, options, function (path, item) {\n        data.push({ path: path, item: item });\n      });\n      expectations(data);\n    });\n\n    it('async', function (done) {\n      var absoluteStartingPath = pathUtil.resolve('abc');\n      var data = [];\n      var st;\n      preparations();\n      st = walker.stream(absoluteStartingPath, options)\n      .on('readable', function () {\n        var a = st.read();\n        if (a) {\n          data.push(a);\n        }\n      })\n      .on('error', console.error)\n      .on('end', function () {\n        expectations(data);\n        done();\n      });\n    });\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-fs-jetpack/node_modules/fs-jetpack/spec/utils/validate.spec.js":"var expect = require('chai').expect;\nvar validate = require('../../lib/utils/validate');\n\ndescribe('util validate', function () {\n  describe('validates arguments passed to methods', function () {\n    it('validates its own input', function () {\n      expect(function () {\n        validate.argument('foo(thing)', 'thing', 123, ['foo']);\n      }).to.throw('Unknown type \"foo\"');\n    });\n\n    [\n      {\n        type: 'string', article: 'a', goodValue: 'abc',\n        wrongValue: 123, wrongValueType: 'number'\n      },\n      {\n        type: 'number', article: 'a', goodValue: 123,\n        wrongValue: 'abc', wrongValueType: 'string'\n      },\n      {\n        type: 'boolean', article: 'a', goodValue: true,\n        wrongValue: 'abc', wrongValueType: 'string'\n      },\n      {\n        type: 'array', article: 'an', goodValue: [],\n        wrongValue: {}, wrongValueType: 'object'\n      },\n      {\n        type: 'object', article: 'an', goodValue: {},\n        wrongValue: [], wrongValueType: 'array'\n      },\n      {\n        type: 'buffer', article: 'a', goodValue: new Buffer(1),\n        wrongValue: 123, wrongValueType: 'number'\n      },\n      {\n        type: 'null', article: 'a', goodValue: null,\n        wrongValue: 123, wrongValueType: 'number'\n      },\n      {\n        type: 'undefined', article: 'an', goodValue: undefined,\n        wrongValue: 123, wrongValueType: 'number'\n      }\n    ]\n    .forEach(function (test) {\n      it('validates that given thing is a(n) ' + test.type, function () {\n        expect(function () {\n          validate.argument('foo(thing)', 'thing', test.goodValue, [test.type]);\n        }).not.to.throw();\n\n        expect(function () {\n          validate.argument('foo(thing)', 'thing', test.wrongValue, [test.type]);\n        }).to.throw('Argument \"thing\" passed to foo(thing) must be ' + test.article\n          + ' ' + test.type + '. Received ' + test.wrongValueType);\n      });\n    });\n\n    [\n      { type: 'string', value: 'abc', expect: 'number' },\n      { type: 'number', value: 123, expect: 'string' },\n      { type: 'boolean', value: true, expect: 'number' },\n      { type: 'array', value: [], expect: 'number' },\n      { type: 'object', value: {}, expect: 'number' },\n      { type: 'buffer', value: new Buffer(1), expect: 'number' },\n      { type: 'null', value: null, expect: 'number' },\n      { type: 'undefined', value: undefined, expect: 'number' }\n    ]\n    .forEach(function (test) {\n      it('can detect wrong type: ' + test.type, function () {\n        expect(function () {\n          validate.argument('foo(thing)', 'thing', test.value, [test.expect]);\n        }).to.throw('Argument \"thing\" passed to foo(thing) must be a '\n          + test.expect + '. Received ' + test.type);\n      });\n    });\n\n    it('supports more than one allowed type', function () {\n      expect(function () {\n        validate.argument('foo(thing)', 'thing', {}, ['string', 'number', 'boolean']);\n      }).to.throw('Argument \"thing\" passed to foo(thing) must be a string'\n        + ' or a number or a boolean. Received object');\n    });\n\n    it('validates array internal data', function () {\n      expect(function () {\n        validate.argument('foo(thing)', 'thing', [1, 2, 3], ['array of number']);\n      }).not.to.throw();\n\n      expect(function () {\n        validate.argument('foo(thing)', 'thing', [1, 2, 'a'], ['array of number']);\n      }).to.throw('Argument \"thing\" passed to foo(thing) must be an array of number.'\n        + ' Received array of number, string');\n    });\n  });\n\n  describe('validates options object', function () {\n    it('options object might be undefined', function () {\n      expect(function () {\n        validate.options('foo(options)', 'options', undefined, { foo: ['string'] });\n      }).not.to.throw();\n    });\n\n    it('option key in options object is optional (doh!)', function () {\n      expect(function () {\n        validate.options('foo(options)', 'options', {}, { foo: ['string'] });\n      }).not.to.throw();\n    });\n\n    it('throws if option key definition not found', function () {\n      expect(function () {\n        validate.options('foo(options)', 'options',\n          { bar: 123 },\n          { foo: ['string'] }\n        );\n      }).to.throw('Unknown argument \"options.bar\" passed to foo(options)');\n    });\n\n    it('validates option', function () {\n      expect(function () {\n        validate.options('foo(options)', 'options',\n          { foo: 'abc' },\n          { foo: ['string'] }\n        );\n      }).not.to.throw();\n\n      expect(function () {\n        validate.options('foo(options)', 'options',\n          { foo: 123 },\n          { foo: ['string'] }\n        );\n      }).to.throw('Argument \"options.foo\" passed to foo(options) must be'\n        + ' a string. Received number');\n    });\n  });\n});\n"}